{
  "hash": "199765f27e09307795beff0f263157de",
  "result": {
    "markdown": "---\ntitle: \"Writing Custom Functions\"\n---\n\n\n## Introduction\n\nA **function** is a set of actions that we group together and name. Throughout this course, you've already used a bunch of different functions in python that are built into the language or added through packages: `mean`, `ggplot`, `merge`, etc. In this chapter, we'll be writing our own functions.\n\n## Defining a function\n\n### When to write a function?\n\nIf you've written the same code (with a few minor changes, like variable names) more than twice, you should probably write a function instead of copy pasting. The motivation behind this is the \"don't repeat yourself\" (DRY) principle. There are a few benefits to this rule:\n\n1. Your code stays neater (and shorter), so it is easier to read, understand, and maintain.\n\n2. If you need to fix the code because of errors, you only have to do it in one place.\n\n3. You can re-use code in other files by keeping functions you need regularly in a file (or if you're really awesome, in your own package!)\n\n4. If you name your functions well, your code becomes easier to understand thanks to grouping a set of actions under a descriptive function name. \n\n\nConsider the following data analysis task done in python:\n\n``` {.python .cell-code}\ndf = pd.DataFrame({'a':np.random.normal(1,1,10), 'b':np.random.normal(2,2,10), 'c':np.random.normal(3,3,10), 'd':np.random.normal(4,4,10)})\n\ndf['a'] = (df['a'] - min(df['a']))/(max(df['a']) - min(df['a']))\n\ndf['b'] = (df['b'] - min(df['a']))/(max(df['b']) - min(df['b']))\n\ndf['c'] = (df['c'] - min(df['c']))/(max(df['c']) - min(df['c']))\n\ndf['d'] = (df['d'] - min(df['d']))/(max(df['d']) - min(df['d']))\n```\n\n\n:::{.callout-check-in .icon}\n\nWhat does this code do?\n\n:::\n\n:::{.callout-example .icon .collapse}\n\nIn theory, the code rescales a set of variables to have a range from 0 to 1. But, because of the copy-pasting, the code's author made a mistake and forgot to change an `a` to `b`!\n\nWriting a function will help us avoid these subtle copy-paste errors.\n\n:::\n\n\n### Building up the function\n\nTo write a function, we first analyze the code to determine how many **inputs** it has\n\n``` {.python .cell-code}\ndf['a'] = (df['a'] - min(df['a']))/(max(df['a']) - min(df['a']))\n```\n\n\nThis code has only one input: `df['a']`. \n\n:::{.callout-check-in .icon}\nWhat is the **object structure** of this input?\n:::\n\nNow we chose an **argument name** for our new input.  It's nice if the argument name reminds the user of what type or structure of object is expected.\n\nIn this case, it might help to replace `df$a` with `vec`.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nvec = df['a'] \n\n(vec - min(vec))/(max(vec) - min(vec))\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n0    0.229221\n1    0.621188\n2    0.000000\n3    0.116435\n4    0.132889\n5    1.000000\n6    0.375171\n7    0.950327\n8    0.404980\n9    0.278691\nName: a, dtype: float64\n```\n:::\n:::\n\n\nThen, we make it a bit easier to read, removing duplicate computations if possible (for instance, computing `min` two times) or separating steps to avoid nested parentheses (for instance, computing `max` first).\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nvec = df['a'] \nmin_vec = min(vec)\nmax_vec = max(vec)\n\n(vec - min_vec)/(max_vec - min_vec)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0    0.229221\n1    0.621188\n2    0.000000\n3    0.116435\n4    0.132889\n5    1.000000\n6    0.375171\n7    0.950327\n8    0.404980\n9    0.278691\nName: a, dtype: float64\n```\n:::\n:::\n\n\nFinally, we turn this code into a function with the `def` command:\n\n``` {.python .cell-code}\ndef rescale_vector(vec):\n  \n  min_vec = min(vec)\n  max_vec = max(vec)\n  \n  rescaled_vec = (vec - min_vec)/(max_vec - min_vec)\n  \n  return rescaled_vec\n```\n\n\n- The name of the function, `rescale_vector`, describes what the function does - it rescales a vector (pandas `Series` or numpy `array`). \n\n- The function takes one **argument**, named `vec`; any references to this value within the function will use `vec` as the name. \n\n- The code that actually does what your function is supposed to do goes in the **body** of the function, after the `:`.  It is important for the body of the function to be *indented*.\n\n- The function **returns** the computed object you want to hand back to the user: in this case, `rescaled_vec`. \n\n:::{.callout-note}\n\nSome people prefer to create a final object and then `return:` that object, as we have done above with `rescaled_vec`. \n\nOthers prefer fewer objects and longer lines of code, i.e.,\n\n``` {.python .cell-code}\ndef rescale_vector(vec):\n  \n  min_vec = min(vec)\n  max_vec = max(vec)\n  \n  return (vec - min_vec)/(max_vec - min_vec)\n```\n\n\nThese two approaches will work identically; it's a matter of personal preference.\n\n:::\n\nThe process for creating a function is important: first, you figure out how to do the thing you want to do. Then, you simplify the code as much as possible. Only at the end of that process do you create an actual function.\n\nNow, we are able to use our function to avoid the repetition:\n\n``` {.python .cell-code}\ndf['a'] = rescale_vector(df['a'])\ndf['b'] = rescale_vector(df['b'])\ndf['c'] = rescale_vector(df['c'])\ndf['d'] = rescale_vector(df['d'])\n```\n\n\nYou probably notice there is still a little bit of repetition here, with `df['a']` appearing on both the left and right side of the `=`.  But this is good repetition!  When we **assign** or **reassign** and object or column, we want that to be an obvious and deliberate choice.\n\nIt's also possible that you might have preferred to keep your original column untouched, and to make new columns for the rescaled data:\n\n``` {.python .cell-code}\ndf['a_scaled'] = rescale_vector(df['a'])\ndf['b_scaled'] = rescale_vector(df['b'])\ndf['c_scaled'] = rescale_vector(df['c'])\ndf['d_scaled'] = rescale_vector(df['d'])\n```\n\n\n### Documenting your function\n\nWhen you want to use a function in `python`, but you can't quite remember exactly how it works, you might be in the habit of typing `?fun_name` or `help(fun_name)` to be able to see the **documentation** for that function.\n\nWhen you write your own function - whether for yourself or for others - it's important to provide reminders of what the function is for and how it works.\n\nWe do this by adding text in a very specific structure into the *body* of our function:\n\n``` {.python .cell-code}\ndef rescale_vector(vec):\n  \n  \"\"\"\n  Rescales a numeric vector to have a max of 1 and min of 0\n  \n  Parameter\n  ---------\n  vec : num\n    A list, numpy array, or pandas Series of numeric data.\n\n  Returns\n  -------\n  array \n    A numpy array containing the rescaled values.\n  \"\"\"\n  \n  min_vec = min(vec)\n  max_vec = max(vec)\n  \n  rescaled_vec = (vec - min_vec)/(max_vec - min_vec)\n  \n  return rescaled_vec\n```\n\n\nA few important aspects of the above to note:\n\n* The use of three quotation marks, `\"\"\"` is necessary for this text to be recognized as official documentation.\n\n* The exact structure of the *Parameters* and *Returns* sections, with underlines, is important for consistency with other documentation.  There are a few other formatting styles that are generally accepted; we'll stick with the one in this example in this course.\n\n* When listing the *arguments*, a.k.a. *parameters* of our function, we specify the name of the argument, the data type that is expected, and a brief description.\n\n* When listing the *returns* of our function, we specify what object structure is being returned, and a brief description.\n\n* The blank line after the final `\"\"\"` is important!\n\n:::{.callout-check-in .icon}\nDefine the function using the code above, then run `help(rescale_vector)`. Pretty satisfying, right?\n:::\n\n\n## Scope\n\nIn the previous example, you might have expected\n\n``` {.python .cell-code}\nrescale_vector(df['a'])\n```\n\n\nto change the column of the `df` object automatically - but it does not, unless you explicitly reassign the results!  This is because everything that happens \"inside\" the function cannot change the status of objects *outside* the function.\n\nThis critical programming concept - determining when objects are changed and when they can be accessed - is called **scope**.\n\nIn general, an object is only available within the **environment** where it was created.  Right now, as you work in your Jupyter notebook or Quarto document, you are interacting with your **global environment**.  Run the `globals()` function to see all the objects you have created and libraries you have loaded so far.\n\nJust as someone sitting next to you on a different computer can't access an object in your own global environment, the *body* of a function is its own *function environment*.\n\nAnything that is created or altered in the function environment does not impact the global environment - locally, you only \"see\" what the function *returns*.\n\n:::{.callout-opinion .icon .collapse}\n\n![Like Las Vegas, what happens in a function stays in that function](https://images.squarespace-cdn.com/content/v1/617299f9fe173949bdf3774a/438f57b3-3c15-4c6f-a423-f433c8a7aa06/DA3B97EC-DFC1-48A1-B7D5-6EC83D784CB4.jpeg)\n:::\n\n\n### Name Masking\n\nScope is most clearly demonstrated when we use the same variable name inside and outside a function. \n\nNote that this is 1) bad programming practice, and 2) fairly easily avoided if you can make your names even slightly more creative than `a`, `b`, and so on. But, for the purposes of demonstration, I hope you'll forgive my lack of creativity in this area so that you can see how name masking works.\n\nConsider the following code:\n\n``` {.python .cell-code}\na = 10\n\ndef myfun(a):\n  \n  a = a + 10\n  \n  return a\n\n\nmyfun(a)\n\na + 5\n```\n\n\n:::{.callout-check-in .icon}\n\n**Without running the code,** what do you think will be printed out by the last two lines of code?\n\n:::\n\n:::{.callout-check-in .icon .collapse}\n\nThe object named `a` within the *function environment*, i.e. the **parameter** of the function, was altered to be equal to `20`.\n\nThen, the function *returned* the value of its parameter `a`, which was `20`.\n\nHere is a sketch of that idea:\n\n![](/images/function-scope.png)\n \nHowever, the object named `a` in our *global environment* is not impacted.  The code `a + 5`, outside the function, still refers to the object in the global environment, which is equal to `10`.\n\n:::\n\n\n### Nested environments and scope\n\nOne thing to notice is that each time the function is run, it creates a new *local environment*.  That is, previous running of a function can't impact future runs of that function.\n\nFor example, this code gives the same answer over and over; it does not continue to add `10` to a copy of `a`, because it never alters the object `a` in the global environment **or** the parameters of the other functions' local environments.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef myfun(a):\n  \n  a = a + 10\n  \n  return a\n\nmyfun(a)\nmyfun(a)\nmyfun(a)\n```\n\n::: {.cell-output .cell-output-error}\n```\nNameError: name 'a' is not defined\n```\n:::\n:::\n\n\nHowever, *all* of the local environments are considered to be **inside** of your global environment.  That is, while they cannot *change* objects in the global environment, they can \"see\" those objects.\n\n\nNotice in the below code that we don't pass *any* arguments to `myfun()`.  But it is still able to compute `b + 1` and return an answer!\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nb = 10\n\ndef myfun():\n  return b + 1\n\nmyfun()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n11\n```\n:::\n:::\n\n\nA function will always look in its *local* environment first; then check the *global* for backups:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nb = 10\n\ndef myfun():\n  b = 20\n  return b + 1\n\nmyfun()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n21\n```\n:::\n:::\n\n\n:::{.callout-warning}\n\nWriting a function that relies on global objects is in general **terrible programming practice**!!!\n\nWhat if you accidentally change or delete that global object?  Suddenly the *exact same code*, i.e. `myfun()` runs differently or not at all.\n\n:::\n\nAlas, although this is bad practice, we quite often \"cheat\" in Data Science and use global references our dataset in function shortcuts, e.g.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\npenguins = load_penguins()\n\ndef plot_my_data(cat_var):\n  \n  plot = (ggplot(penguins, aes(x = cat_var)) + geom_bar())\n  \n  return plot\n  \n  \nplot_my_data('species')\n\n```\n\n::: {.cell-output .cell-output-display}\n![](05-function_writing_files/figure-html/cell-17-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n<Figure Size: (640 x 480)>\n```\n:::\n:::\n\n\n:::\n\n\nThis \"trick\" is sometimes called **Dynamic Lookup**.  You should mostly avoid it; but when you use it carefully and deliberately in the context of a specific data analysis, it can be a convenient approach.\n\n\n:::{.callout-check-in .icon}\n\nWrite a custom function that does the following:\n\n1. Limit the `penguins` dataset to a user-chosen species and/or island.\n2. Makes a scatterplot of the penguin bill length and depth.\n\nTry writing a version of this function using *dynamic lookup*, and a version where everything the function needs is passed in directly.\n\n:::\n\n\n\n## Unit tests\n\nSo: You have now written your first custom function. Hooray!\n\n![](https://media4.giphy.com/media/o0vwzuFwCGAFO/200w.gif?cid=6c09b95270i5owrqfq3sk999kzhseqa0r1o6nn4l3og9n2yn&ep=v1_gifs_search&rid=200w.gif&ct=g)\n\nNow, before you move on to further analysis, you have an important job to do.  You need to make sure that your function will work - or will break in a helpful way - when users give unexpected input.\n\n### Unit testing\n\nThe absolute most important thing to do after defining a function is to run some **unit tests**.\n\nThis refers to snippets of code that will try your function out on both \"ordinary\" user input, and strange or unexpected user input.  \n\nFor example, consider the `plot_my_data` function defined above.  We immediately *unit tested* it by running\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nplot_my_data('species')\n```\n\n::: {.cell-output .cell-output-display}\n![](05-function_writing_files/figure-html/cell-18-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n<Figure Size: (640 x 480)>\n```\n:::\n:::\n\n\nBut what if someone tried to enter the name of a variable that is not categorical?   Or a variable that doesn't exist in the `penguins` dataset? Or an input that is not a variable name (string)?  Or no input at all?\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nplot_my_data('bill_length_mm')\n\nplot_my_data('name')\n\nplot_my_data(5)\n\nplot_my_data(True)\n\nplot_my_data()\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: plot_my_data() missing 1 required positional argument: 'cat_var'\n```\n:::\n:::\n\n\n:::{.callout-example .icon}\nAre all of these outputs what you expected?  Why or why not?  Can you explain why the unexpected behavior happened?\n:::\n\n\n\n### Input Validation\n\nWhen you write a function, you often assume that your parameters will be of a certain type. But as we saw above, you can't guarantee that the person using your function knows that they need a certain type of input, and they might be confused by how your function handles that input. In these cases, it's best to **validate** your function input.\n\n#### `if-else` and `sys.exit`\n\nGenerally your approach to validation will be to check some conditions, and **exit** the function if they are not met.  The function `exit()` from the `sys` library is a good approach.  You want to make sure you write an *informative* error statement in your exit, so that the user knows how to fix what went wrong.\n\n:::{.callout-learn-more .icon}\n[This article](https://uxwritinghub.com/error-message-examples/) provides a short guide to writing informative error messages.\n:::\n\n\nThe most common condition checking is to make sure the object type is correct - i.e., that the user inputs a string, and that the string refers to a **categorical** (a.k.a. \"object\") variable in the `penguins` dataset.\n\nRecall that you can \"reverse\" a boolean (`True` or `False`) value using the `not` statement.  Sometimes, it is easier to check if a condition is **not** met than to list all the \"good\" conditions.\n\nPutting these together, we can check if our user input to `plot_my_data` is what we expect:\n\n``` {.python .cell-code}\nfrom sys import exit\n\ndef plot_my_data(cat_var):\n    \n  if not isinstance(cat_var, str):\n    exit(\"Please provide a variable name in the form of a string.\")\n    \n  if not (cat_var in penguins.columns):\n    exit(\"The variable provided is not found in the penguins dataset.\")\n    \n  if not penguins[cat_var].dtypes == 'object':\n    exit(\"Please provide the name of a categorical (object type) variable.\")\n  \n  plot = (ggplot(penguins, aes(x = cat_var)) + geom_bar())\n  \n  return plot\n```\n\n\n:::{.callout-warning .icon}\nNotice that we have used the `isinstance` base python function to check that the user inputted a string; but we have used the `dtype` method to check the data type of the column of data in a `pandas` dataframe.\n\nWhen checking types and structures, be careful about \"special\" object types from packages, like `pandas` data frames or `numpy` arrays - they each unfortunately have their own type checking functions *and* their own names for types. \n:::\n\nNow, let's retry our unit tests:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nplot_my_data('bill_length_mm')\n\nplot_my_data('name')\n\nplot_my_data(5)\n\nplot_my_data(True)\n\nplot_my_data()\n```\n\n::: {.cell-output .cell-output-error}\n```\nSystemExit: Please provide the name of a categorical (object type) variable.\n```\n:::\n:::\n\n\nInput validation is one aspect of **defensive programming** - programming in such a way that you try to ensure that your programs don't error out due to unexpected bugs by anticipating ways your programs might be misunderstood or misused. If you're interested, Wikipedia has [more about defensive programming](https://en.wikipedia.org/wiki/Defensive_programming).\n\n\n\n## Debugging\n\nNow that you're writing functions, it's time to talk a bit about debugging techniques. This is a lifelong topic - as you become a more advanced programmer, you will need to develop more advanced debugging skills as well (because you'll find newer and more exciting ways to break your code!). \n\n![The faces of debugging (by Allison Horst)](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/51084276-ab7f-4c57-a0e7-5cf14a277359_rw_1920.png?h=825c5593149a63edef46664796766751)\n\nLet's start with the basics: print debugging.\n\n### Print Debugging\n\nThis technique is basically exactly what it sounds like. You insert a ton of print statements to give you an idea of what is happening at each step of the function.\n\nLet's try it out on the `rescale_vector` function.\n\n``` {.python .cell-code}\ndef rescale_vector(vec):\n  \n  min_vec = min(vec)\n  max_vec = max(vec)\n  \n  rescaled = (vec - min_vec)/(max_vec - min_vec)\n  \n  return rescaled\n```\n\n\nSuppose we try the following:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nmy_vec = [-1,0,1,2,3]\n\nmy_vec = np.sqrt(my_vec)\n\nrescale_vector(my_vec)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([nan, nan, nan, nan, nan])\n```\n:::\n:::\n\n\nYou probably have spotted the issue here, but what if it wasn't obvious, and we wanted to know why our function was returning an array of `nan` values.\n\nIs the culprit the min?  The max?\n\n``` {.python .cell-code}\ndef rescale_vector(vec):\n  \n  min_vec = min(vec)\n  print(\"min: \" + str(min_vec))\n  \n  max_vec = max(vec)\n  print(\"max: \" + str(max_vec))\n  \n  rescaled = (vec - min_vec)/(max_vec - min_vec)\n  \n  return rescaled\n```\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nrescale_vector(my_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmin: nan\nmax: nan\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\narray([nan, nan, nan, nan, nan])\n```\n:::\n:::\n\n\n:::{.callout-note}\n\nNotice how the `print()` statements cause information to get printed out as the function ran, but did not change the `return` value of the function!\n\n:::\n\nHmmm, both the min and the max were `nan`.  This explains why our rescaling introduced all missing values!\n\nSo, the issue must be with the user input itself. Let's rewrite our function to take a look at that.\n\n``` {.python .cell-code}\ndef rescale_vector(vec):\n  \n  print(vec)\n  \n  min_vec = min(vec)\n  max_vec = max(vec)\n  \n  rescaled = (vec - min_vec)/(max_vec - min_vec)\n  \n  return rescaled\n```\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nrescale_vector(my_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[       nan 0.         1.         1.41421356 1.73205081]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\narray([nan, nan, nan, nan, nan])\n```\n:::\n:::\n\n\nAh-ha!  The first value of the input vector is a `nan`.\n\nIdeally, the user would not input a vector with missing values.  But it's our job to make sure the function is prepared to handle them.\n\n:::{.callout-check-in .icon}\n\nAdd code to the `rescale_vector` function definition to check if the vector has any `nan` values, and give an informative error message if so.\n\n:::\n\n\n:::{.callout-check-in .icon}\n\nThink of other options for handling `nan`s in user input in this function.  What are the pros and cons of writing functions that are **opinionated** - i.e., that give errors unless the user input is perfect - versus functions that try to work with imperfect input?\n\n:::\n\n\n### Beyond print statements: breakpoints\n\nWhile `print()` statements work fine as a quick-and-dirty debugging strategy, you will soon get tired of using them, since you have to change your function and reload it every time you want to check something.\n\nA more elegant - and ultimately easier - approach is to \"dive in\" to the environment of the function itself, where you can interact with the *parameters* in the *local environment* the same way you might interact with your *global environment*.\n\nTo do this, we will set a **breakpoint** in our function.  This will cause the function to run until that point, and then stop and let us play around in the environment.\n\n``` {.python .cell-code}\ndef rescale_vector(vec):\n  \n  breakpoint()\n  \n  min_vec = min(vec)\n  max_vec = max(vec)\n  \n  rescaled = (vec - min_vec)/(max_vec - min_vec)\n  \n  return rescaled\n```\n\n\n:::{.callout-check-in}\n\nSet a breakpoint in your `rescale_vector` code, as above, and then run the function on a vector.  \n\nPlay around with the interface of the local environment until you get used to this.\n\n:::\n\n### `pdb` (\"python de-bugger\")\n\nAlthough setting breakpoints can be much cleaner and more convenient than several `print()` statements, using `breakpoint()` still required us to modify and reload the function.\n\nThe most advanced and clean approach to debugging is to use the `pdb` library to dive straight in to the local environment.\n\n``` {.python .cell-code}\ndef rescale_vector(vec):\n  \n  min_vec = min(vec)\n  max_vec = max(vec)\n  \n  rescaled = (vec - min_vec)/(max_vec - min_vec)\n  \n  return rescaled\n```\n\n\n``` {.python .cell-code}\nimport pdb\npdb.run(\"rescale_vector(my_vec)\")\n```\n\n\n:::{.callout-check-in .icon}\n\nTry the above debugging approach.\n\n:::\n\n\n\n## General Debugging Strategies\n\n> Debugging: Being the detective in a crime movie where you are also the murderer.\n\nThe overall process of addressing a bug is:\n\n0. **Realize that you have a bug**\n\n1. **Google!** Generally Googling the error + the programming language + any packages you think are causing the issue is a good strategy.\n\n2. **Make the error repeatable**: This makes it easier to figure out what the error is, faster to re-try to see if you fixed it, and easier to ask for help.  Unit tests are perfect for this.\n\n3. **Figure out where it is**. Print statements and debuggers help you dig into the function to find the problem area.\n\n4. **Fix it and test it**. The goal with tests is to ensure that the same error doesn't pop back up in a future version of your code. Generate an example that will test for the error, and add it to your documentation. \n\n\n### Rubber Duck debugging\n\nHave you ever called a friend or teacher over for help with an issue, only to find that by explaining it to them, you solved it yourself?\n\nTalking through your code out loud is an extremely effective way to spot problems. In programming, we call this **Rubber Duck Debugging**, because coders will sometimes keep a small toy like a rubber duck by their computer, and talk to it while they are alone.\n\n![This is the original RickRoll.  Yes, really.](https://i.kym-cdn.com/entries/icons/original/000/000/305/duckroll169.jpg)\n\n\n:::{.callout-learn-more .icon}\n[A more thorough explanation of rubber duck debugging can be found at gitduck.com](https://gitduck.com/blog/improve-how-to-code-with-rubber-duck-debugging/). \n:::\n\n\n### Refactoring your code \n\n> “Divide each difficulty into as many parts as is feasible and necessary to resolve it.” -René Descartes, Discourse on Method \n\nIn programming, as in life, big, general problems are very hard to solve effectively. Instead, the goal is to break a problem down into smaller pieces that may actually be solveable. \n\nWhen we redesign our functions to consist of many smaller functions, this is called **refactoring**.  Consider the following function:\n\n``` {.python .cell-code}\ndef rescale_all_variables(df):\n  \n  for col in df.columns:\n    \n    min_vec = min(df[col])\n    max_vec = max(df[col])\n  \n    df[col] = (df[col] - min_vec)/(max_vec - min_vec)\n    \n  \n  return df\n```\n\n\nA much cleaner and easier to read way to use this function would be to use the smaller function `rescale_vector` *inside of* `rescale_all_variables`\n\n``` {.python .cell-code}\ndef rescale_all_variables(df):\n  \n  for col in df.columns:\n    df[col] = rescale_vector(df[col])\n  \n  return df\n```\n\n\nThis not only makes the code more readable to humans, it also helps us track down whether the error is happening in the outside function (`rescale_all_variables`) or the inside one (`rescale_vector`)\n\n### Taking a break!\n\n\nDo not be surprised if, in the process of debugging, you encounter new bugs. This is a problem that's so well-known it has an [xkcd comic](https://xkcd.com/1739/). \n\nAt some point, getting up and going for a walk may help!\n\n  \n:::{.callout-practice-exercise .icon}\n[Click here](https://colab.research.google.com/drive/1iQ3KOgMgSWGihOBGMvKxjdQysgmL0d7P?usp=sharing) to answer a few questions about function code.\n:::\n\n",
    "supporting": [
      "05-function_writing_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}