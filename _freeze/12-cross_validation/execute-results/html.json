{
  "hash": "afa3dc1568b0721dc938204e492de156",
  "result": {
    "markdown": "---\ntitle: \"Pipelines, Cross-Validation, and Tuning\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nreticulate::use_python(\"/usr/local/bin/python3\")\n```\n:::\n\n\n\n## Introduction\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder, PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import r2_score\n```\n:::\n\n\n## Pipelines\n\nIn the last two chapters, we learned to use `sklearn` and `python` to perform the main steps of the modeling procedure:\n\n1. **Preprocessing:** Choosing which predictors to include, and how we will transform them to prepare them for the model, e.g. `pd.get_dummies()` or `StandardScaler()`\n\n2. **Model Specification:**  Choosing the *procedure* we will use to make sure predictions; e.g. `LinearRegression()` or `NearestNeighborsRegressor()`\n\n3. **Fitting on training data:** Using `train_test_split()` to establish a randomly chosen training set, then using `.fit()` to fit the model on that set.\n\n4. **Validating on test data:** Using `.predict` to make predictions on the test set, and then computing desired metrics to compare models, like `rmse()` or `r2()`.\n\nIn this chapter, we will combine all these steps into one **pipeline**, sometimes called a **workflow**, to streamline our modeling process. \n\nThen, we will use our pipeline objects to quickly and easily perform more complex model fitting and validation tasks.\n\n## Pipelines\n\nIf we already know how to perform each modeling step, why would we need pipelines?  Consider the following cautionary tale...\n\n### Cautionary Tale:\n\n#### Chapter One\n\nSuppose you want to predict (of course) house prices from house characteristics.  You might take an approach like this:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlr = LinearRegression()\n\n\names = pd.read_csv(\"data/AmesHousing.csv\")\nX = ames[[\"Gr Liv Area\", \"TotRms AbvGrd\"]]\ny = ames[\"SalePrice\"]\n\n\n\nX_train, X_test, y_train, y_test = train_test_split(X, y)\n\nX_train_s = (X_train - X_train.mean())/X_train.std()\n\nlr_fitted = lr.fit(X_train_s, y_train)\nlr_fitted.coef_\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([ 71206.33060511, -16630.41352368])\n```\n:::\n:::\n\n\nThen, you decide to apply your fitted model to the test data:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ny_preds = lr_fitted.predict(X_test)\n\nr2_score(y_test, y_preds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-2172982.6511352574\n```\n:::\n:::\n\n\nOh no!  An $R^2$ score of *negative 2 million*???  How could this have happened?\n\nLet's look at the predictions:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ny_preds[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([6.96124020e+07, 1.86860652e+08, 6.16372930e+07, 1.48886363e+08])\n```\n:::\n:::\n\n\nWow.  We predicted that the first five test houses would all be worth over $50 million dollars.  That doesn't seem quite right.\n\n:::{.callout-check-in .icon}\nWhat went wrong here?\n:::\n\n#### Chapter Two\n\nNow a new house has come along, and you need to predict it.  That house has a\nliving area of 889 square feet, and 6 rooms.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnew_house = pd.DataFrame(data = {\"Gr Liv Area\": [889], \"TotRms AbvGrd\": [6]})\nnew_house\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Gr Liv Area  TotRms AbvGrd\n0          889              6\n```\n:::\n:::\n\n\nWe won't make the same mistake again!  Time to standardize our new data:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnew_house_s = (new_house - new_house.mean())/new_house.std()\nnew_house_s\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Gr Liv Area  TotRms AbvGrd\n0          NaN            NaN\n```\n:::\n:::\n\n\nOh no!  Our data is now all `NaN`!!!\n\n:::{.callout-check-in .icon}\nWhat happened this time, and how can we fix it?\n:::\n\n#### The Moral of the Story\n\nA massively important principle of the modeling process is:  **New data that we want to predict on must go through the exact same pre-processing as the training data.**\n\nBy *\"exact same\"*, we don't mean *\"same idea\"*, we mean *the same calculations*.\n\nTo standardize our training data, we subtracted from each column its mean *in the training data*, and then divided each column by the standard deviation *in the training data*.  Thus, for any new data that comes along - whether it is a larger test dataset, or a single new house to predict on - we need to use the **same numbers** to standardize:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nX_test_s = (X_test - X_train.mean())/X_train.std()\ny_preds = lr_fitted.predict(X_test_s)\n\nr2_score(y_test, y_preds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.4896807414885571\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nnew_house_s = (new_house - X_train.mean())/X_train.std()\nlr_fitted.predict(new_house_s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([99061.19539145])\n```\n:::\n:::\n\n\nNotice that we used `X_train.mean()` and `X_train.std()` in each case: we \"learned\" our estimates for the mean and sd of the columns when we **fit** the model, and we use those for all future predictions!\n\n### Pipeline Objects\n\nNow, for an easier way to make sure preprocessing happens correctly.  Instead of making a **model** object, like `LinearRegression()`, that we use for fitting and predicting, we will make a **pipeline** object that contains *all* our steps:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlr_pipeline = Pipeline(\n  [StandardScaler(),\n  LinearRegression()]\n)\n\nlr_pipeline\n```\n\n::: {.cell-output-display}\n```{=html}\n<style>#sk-container-id-1 {color: black;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: \"▸\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"▾\";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id=\"sk-container-id-1\" class=\"sk-top-container\"><div class=\"sk-text-repr-fallback\"><pre>Pipeline(steps=[StandardScaler(), LinearRegression()])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class=\"sk-container\" hidden><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-1\" type=\"checkbox\" checked><label for=\"sk-estimator-id-1\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">Pipeline</label><div class=\"sk-toggleable__content\"><pre>Pipeline(steps=[StandardScaler(), LinearRegression()])</pre></div></div></div></div></div>\n```\n:::\n:::\n\n\nWe can even name the steps in our pipeline, in order to help us keep track of them:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlr_pipeline = Pipeline(\n  [(\"standardize\", StandardScaler()),\n  (\"linear_regression\", LinearRegression())]\n)\n\nlr_pipeline\n```\n\n::: {.cell-output-display}\n```{=html}\n<style>#sk-container-id-2 {color: black;}#sk-container-id-2 pre{padding: 0;}#sk-container-id-2 div.sk-toggleable {background-color: white;}#sk-container-id-2 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-2 label.sk-toggleable__label-arrow:before {content: \"▸\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-2 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-2 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-2 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-2 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-2 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-2 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"▾\";}#sk-container-id-2 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-2 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-2 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-2 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-2 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-2 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-2 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-2 div.sk-item {position: relative;z-index: 1;}#sk-container-id-2 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-2 div.sk-item::before, #sk-container-id-2 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-2 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-2 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-2 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-2 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-2 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-2 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-2 div.sk-label-container {text-align: center;}#sk-container-id-2 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-2 div.sk-text-repr-fallback {display: none;}</style><div id=\"sk-container-id-2\" class=\"sk-top-container\"><div class=\"sk-text-repr-fallback\"><pre>Pipeline(steps=[(&#x27;standardize&#x27;, StandardScaler()),\n                (&#x27;linear_regression&#x27;, LinearRegression())])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class=\"sk-container\" hidden><div class=\"sk-item sk-dashed-wrapped\"><div class=\"sk-label-container\"><div class=\"sk-label sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-2\" type=\"checkbox\" ><label for=\"sk-estimator-id-2\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">Pipeline</label><div class=\"sk-toggleable__content\"><pre>Pipeline(steps=[(&#x27;standardize&#x27;, StandardScaler()),\n                (&#x27;linear_regression&#x27;, LinearRegression())])</pre></div></div></div><div class=\"sk-serial\"><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-3\" type=\"checkbox\" ><label for=\"sk-estimator-id-3\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">StandardScaler</label><div class=\"sk-toggleable__content\"><pre>StandardScaler()</pre></div></div></div><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-4\" type=\"checkbox\" ><label for=\"sk-estimator-id-4\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">LinearRegression</label><div class=\"sk-toggleable__content\"><pre>LinearRegression()</pre></div></div></div></div></div></div></div>\n```\n:::\n:::\n\n\n:::{.callout-caution}\nPay careful attention to the use of `[` and `(` inside the `Pipeline` function.  The function takes a **list** (`[]`) of steps; each step may be put into a **tuple** `()` with a name of your choice.\n:::\n\nNow, we can use this pipeline for all our modeling tasks, without having to worry about doing the standardizing ourselves ahead of time:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlr_pipeline_fitted = lr_pipeline.fit(X_train, y_train)\n\ny_preds = lr_pipeline_fitted.predict(X_test)\nr2_score(y_test, y_preds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.489680741488557\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nlr_pipeline_fitted.predict(new_house)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([99061.19539145])\n```\n:::\n:::\n\n\n### Column Transformers\n\nBecause there may be many different steps to the data preprocessing, it can sometimes be convenient to separate these steps into individual *column transformers*.\n\nFor example, suppose you wanted to include a third predictor in your house price prediction: The type of building it is (`Bldg Type`); e.g., a Townhouse, a single-family home, etc.\n\nSince this is a categorical variable, we need to turn it into dummy variables first, using `OneHotEncoder()`.  But we don't want to put `OneHotEncoder()` directly into our pipeline, because we don't want to dummify *every* variable!\n\nSo, we'll make column transformers to handle our variables separately:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom sklearn.compose import ColumnTransformer\n\nct = ColumnTransformer(\n  [\n    (\"dummify\", OneHotEncoder(sparse_output = False), [\"Bldg Type\"]),\n    (\"standardize\", StandardScaler(), [\"Gr Liv Area\", \"TotRms AbvGrd\"])\n  ],\n  remainder = \"drop\"\n)\n\n\nlr_pipeline = Pipeline(\n  [(\"preprocessing\", ct),\n  (\"linear_regression\", LinearRegression())]\n)\n\nlr_pipeline\n```\n\n::: {.cell-output-display}\n```{=html}\n<style>#sk-container-id-3 {color: black;}#sk-container-id-3 pre{padding: 0;}#sk-container-id-3 div.sk-toggleable {background-color: white;}#sk-container-id-3 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-3 label.sk-toggleable__label-arrow:before {content: \"▸\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-3 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-3 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-3 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-3 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-3 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-3 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"▾\";}#sk-container-id-3 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-3 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-3 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-3 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-3 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-3 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-3 div.sk-item {position: relative;z-index: 1;}#sk-container-id-3 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-3 div.sk-item::before, #sk-container-id-3 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-3 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-3 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-3 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-3 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-3 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-3 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-3 div.sk-label-container {text-align: center;}#sk-container-id-3 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-3 div.sk-text-repr-fallback {display: none;}</style><div id=\"sk-container-id-3\" class=\"sk-top-container\"><div class=\"sk-text-repr-fallback\"><pre>Pipeline(steps=[(&#x27;preprocessing&#x27;,\n                 ColumnTransformer(transformers=[(&#x27;dummify&#x27;,\n                                                  OneHotEncoder(sparse_output=False),\n                                                  [&#x27;Bldg Type&#x27;]),\n                                                 (&#x27;standardize&#x27;,\n                                                  StandardScaler(),\n                                                  [&#x27;Gr Liv Area&#x27;,\n                                                   &#x27;TotRms AbvGrd&#x27;])])),\n                (&#x27;linear_regression&#x27;, LinearRegression())])</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class=\"sk-container\" hidden><div class=\"sk-item sk-dashed-wrapped\"><div class=\"sk-label-container\"><div class=\"sk-label sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-5\" type=\"checkbox\" ><label for=\"sk-estimator-id-5\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">Pipeline</label><div class=\"sk-toggleable__content\"><pre>Pipeline(steps=[(&#x27;preprocessing&#x27;,\n                 ColumnTransformer(transformers=[(&#x27;dummify&#x27;,\n                                                  OneHotEncoder(sparse_output=False),\n                                                  [&#x27;Bldg Type&#x27;]),\n                                                 (&#x27;standardize&#x27;,\n                                                  StandardScaler(),\n                                                  [&#x27;Gr Liv Area&#x27;,\n                                                   &#x27;TotRms AbvGrd&#x27;])])),\n                (&#x27;linear_regression&#x27;, LinearRegression())])</pre></div></div></div><div class=\"sk-serial\"><div class=\"sk-item sk-dashed-wrapped\"><div class=\"sk-label-container\"><div class=\"sk-label sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-6\" type=\"checkbox\" ><label for=\"sk-estimator-id-6\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">preprocessing: ColumnTransformer</label><div class=\"sk-toggleable__content\"><pre>ColumnTransformer(transformers=[(&#x27;dummify&#x27;, OneHotEncoder(sparse_output=False),\n                                 [&#x27;Bldg Type&#x27;]),\n                                (&#x27;standardize&#x27;, StandardScaler(),\n                                 [&#x27;Gr Liv Area&#x27;, &#x27;TotRms AbvGrd&#x27;])])</pre></div></div></div><div class=\"sk-parallel\"><div class=\"sk-parallel-item\"><div class=\"sk-item\"><div class=\"sk-label-container\"><div class=\"sk-label sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-7\" type=\"checkbox\" ><label for=\"sk-estimator-id-7\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">dummify</label><div class=\"sk-toggleable__content\"><pre>[&#x27;Bldg Type&#x27;]</pre></div></div></div><div class=\"sk-serial\"><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-8\" type=\"checkbox\" ><label for=\"sk-estimator-id-8\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">OneHotEncoder</label><div class=\"sk-toggleable__content\"><pre>OneHotEncoder(sparse_output=False)</pre></div></div></div></div></div></div><div class=\"sk-parallel-item\"><div class=\"sk-item\"><div class=\"sk-label-container\"><div class=\"sk-label sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-9\" type=\"checkbox\" ><label for=\"sk-estimator-id-9\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">standardize</label><div class=\"sk-toggleable__content\"><pre>[&#x27;Gr Liv Area&#x27;, &#x27;TotRms AbvGrd&#x27;]</pre></div></div></div><div class=\"sk-serial\"><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-10\" type=\"checkbox\" ><label for=\"sk-estimator-id-10\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">StandardScaler</label><div class=\"sk-toggleable__content\"><pre>StandardScaler()</pre></div></div></div></div></div></div></div></div><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-11\" type=\"checkbox\" ><label for=\"sk-estimator-id-11\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">LinearRegression</label><div class=\"sk-toggleable__content\"><pre>LinearRegression()</pre></div></div></div></div></div></div></div>\n```\n:::\n:::\n\n:::{.callout-check-in}\nWhat does the `remainder = \"drop\"` part of the `ColumnTransformer()` function do?\nWhy might that be useful?\n\nHint: What happens when you try to fit this pipeline on `X_train`?\n:::\n\n\n::: {.cell}\n\n```{.python .cell-code}\nX = ames.drop(\"SalePrice\", axis = 1)\ny = ames[\"SalePrice\"]\n\n\n\nX_train, X_test, y_train, y_test = train_test_split(X, y)\n\nlr_fitted = lr_pipeline.fit(X_train, y_train)\n```\n:::\n\n\n\n\n#### Checking preprocessing\n\nWe've seen the value of including preprocessing steps in a pipeline instead of doing them \"by hand\".  However, you might sometimes want to see what that processed data\nlooks like.  This is one advantage of a column transformer - it can be separately used to `fit` and `transform` datasets:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nct_fitted = ct.fit(X_train)\n\nct.transform(X_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([[ 1.        ,  0.        ,  0.        , ...,  0.        ,\n        -0.07396826,  0.98038937],\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n         0.69303478,  0.34744331],\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n         1.08858346,  0.98038937],\n       ...,\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n        -0.30487231, -0.91844881],\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n        -0.0097167 ,  0.34744331],\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n         0.03646411,  0.98038937]])\n```\n:::\n\n```{.python .cell-code}\nct.transform(X_test)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([[ 1.        ,  0.        ,  0.        , ...,  0.        ,\n         2.02223899,  1.61333543],\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n        -0.09003115, -0.28550275],\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n        -0.63616944, -0.28550275],\n       ...,\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n        -1.01364737, -0.91844881],\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n         0.27339175,  1.61333543],\n       [ 1.        ,  0.        ,  0.        , ...,  0.        ,\n         1.35362116,  1.61333543]])\n```\n:::\n:::\n\n\n\n### Challenges of pipelines\n\nAlthough `Pipeline` objects are incredible tools for making sure your model process is reproducible and correct, they come with some frustrations.  Here are a few you might encounter, and our advice for dealing with them:\n\n#### Extracting information\n\nWhen we wanted to find the fitted coefficients of a model object, we could simply use `.coef_`.  However, since a `Pipeline` is not a model object, this no longer works:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlr_pipeline_fitted.coef_\n```\n\n::: {.cell-output .cell-output-error}\n```\n'Pipeline' object has no attribute 'coef_'\n```\n:::\n:::\n\n\nWhat we need to do instead is find the *step* of the pipeline where the model fitting happened, and get those coefficients:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlr_pipeline_fitted.named_steps['linear_regression'].coef_\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narray([ 71190.12340549, -16626.62829238])\n```\n:::\n:::\n\n\n\n\n#### Pandas input, numpy output\n\nYou may have noticed that `sklearn` functions are designed to handle `pandas` objects nicely - which is a good thing, since we like to do our data cleaning and manipulation in `pandas`!  However, the outputs of these model functions are typically `numpy` arrays:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntype(y_preds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'numpy.ndarray'>\n```\n:::\n:::\n\n\nOccasionally, this can cause trouble; especially when you want to continue data manipulation after making predictions.\n\nFortunately, it is possible to set up your pipeline to output `pandas` objects instead, using the `set_output()` method:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlr_pipeline = Pipeline(\n  [(\"preprocessing\", ct),\n  (\"linear_regression\", LinearRegression())]\n).set_output(transform=\"pandas\")\n\n\nct.fit_transform(X_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      dummify__Bldg Type_1Fam  ...  standardize__TotRms AbvGrd\n2411                      1.0  ...                    0.980389\n824                       1.0  ...                    0.347443\n58                        1.0  ...                    0.980389\n737                       1.0  ...                   -0.285503\n2748                      1.0  ...                    0.980389\n...                       ...  ...                         ...\n2840                      1.0  ...                    0.347443\n758                       1.0  ...                   -1.551395\n2157                      1.0  ...                   -0.918449\n2739                      1.0  ...                    0.347443\n2315                      1.0  ...                    0.980389\n\n[2197 rows x 7 columns]\n```\n:::\n:::\n\n\n:::{.callout-warning}\n\nNotice that in this transformed dataset, the column names now have prefixes for the named steps in the column transformer.\n\nNotice also the structure of the names of the dummified variables:\n\n`[step name]__[variable name]_[category]`\n\n:::\n\n\n#### Interactions and Dummies\n\nSometimes, we want to include an **interaction term** in our model; for example,\n\n$$ \\text{House Price} = \\text{House Size} + \\text{Num Rooms} + \\text{Size}*\\text{Rooms}$$\n\nAdding interactions between numeric variables is simple, we simply add a \"polynomial\" step to our preprocessing, except we leave off the squares and cubes, and keep only the interactions:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nct_inter = ColumnTransformer(\n  [\n    (\"interaction\", PolynomialFeatures(interaction_only = True), [\"Gr Liv Area\", \"TotRms AbvGrd\"])\n  ],\n  remainder = \"drop\"\n).set_output(transform = \"pandas\")\n\nct_inter.fit_transform(X_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      interaction__1  ...  interaction__Gr Liv Area TotRms AbvGrd\n2411             1.0  ...                                 11648.0\n824              1.0  ...                                 12866.0\n58               1.0  ...                                 16280.0\n737              1.0  ...                                  6852.0\n2748             1.0  ...                                 15288.0\n...              ...  ...                                     ...\n2840             1.0  ...                                  8750.0\n758              1.0  ...                                  6664.0\n2157             1.0  ...                                  6705.0\n2739             1.0  ...                                 10416.0\n2315             1.0  ...                                 12088.0\n\n[2197 rows x 4 columns]\n```\n:::\n:::\n\n\nHowever, to add an interaction with a dummified variable, we first need to know what the *new* column names are after the dummification step.\n\nFor example, suppose we wanted to add an interaction term for the number of rooms in the house and whether the house is a single family home.\n\nWe'll need to run the data through one preprocessing step, to get the dummy variables, then a *second* preprocessing that uses those variables.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nct_dummies = ColumnTransformer(\n  [(\"dummify\", OneHotEncoder(sparse_output = False), [\"Bldg Type\"])],\n  remainder = \"passthrough\"\n).set_output(transform = \"pandas\")\n\nct_inter = ColumnTransformer(\n  [\n    (\"interaction\", PolynomialFeatures(interaction_only = True), [\"remainder__TotRms AbvGrd\", \"dummify__Bldg Type_1Fam\"]),\n  ],\n  remainder = \"drop\"\n).set_output(transform = \"pandas\")\n\nX_train_dummified = ct_dummies.fit_transform(X_train)\nX_train_dummified\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      dummify__Bldg Type_1Fam  ...  remainder__Sale Condition\n2411                      1.0  ...                    Partial\n824                       1.0  ...                     Normal\n58                        1.0  ...                     Normal\n737                       1.0  ...                     Normal\n2748                      1.0  ...                     Normal\n...                       ...  ...                        ...\n2840                      1.0  ...                     Normal\n758                       1.0  ...                     Normal\n2157                      1.0  ...                     Normal\n2739                      1.0  ...                     Normal\n2315                      1.0  ...                     Normal\n\n[2197 rows x 85 columns]\n```\n:::\n\n```{.python .cell-code}\nct_inter.fit_transform(X_train_dummified)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      interaction__1  ...  interaction__remainder__TotRms AbvGrd dummify__Bldg Type_1Fam\n2411             1.0  ...                                                8.0            \n824              1.0  ...                                                7.0            \n58               1.0  ...                                                8.0            \n737              1.0  ...                                                6.0            \n2748             1.0  ...                                                8.0            \n...              ...  ...                                                ...            \n2840             1.0  ...                                                7.0            \n758              1.0  ...                                                4.0            \n2157             1.0  ...                                                5.0            \n2739             1.0  ...                                                7.0            \n2315             1.0  ...                                                8.0            \n\n[2197 rows x 4 columns]\n```\n:::\n:::\n\n\nOoof!  This is not very elegant, we admit.  But it is still worth the effort to set up a full pipeline, instead of transforming things by hand, as we will see in the next section.\n\n### Your turn\n\n:::{.callout-practice-exercise .icon}\n\nConsider four possible models for predicting house prices:\n\n1. Using only the size and number of rooms.\n2. Using size, number of rooms, and building type.\n3. Using size and building type, and their interaction.\n4. Using a 5-degree polynomial on size, a 5-degree polynomial on number of rooms, and also building type.\n\nSet up a pipeline for each of these three models.\n\nThen, get predictions on the test set for each of your pipelines, and compute the root mean squared error.  Which model performed best?\n\nNote: You should only use the function `train_test_split()` **one** time in your code; that is, we should be predicting on the **same** test set for all three models.\n\n:::\n\n\n## Cross-Validation\n\n\n",
    "supporting": [
      "12-cross_validation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}