{
  "hash": "f7f1d8d10a8789295562950a670cd90a",
  "result": {
    "markdown": "---\ntitle: \"Strings and Regular Expressions\"\n---\n\n## Introduction\n\nThis chapter goes into more detail on dealing with **string objects**, using methods and regular expressions.\n\n\n::: callout-note\nMany of the functions in this chapter are from a library called `re`.  This is built into base python, so you do not need to install it!\n:::\n\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n```\n\n\n## String Methods\n\nWe have already seen many examples so far of objects that have the `string` data type.  These might be referred to as `str` or `character` or `object`, depending on the library we are using to check type.\n\nString objects can be combined with the `+` operator:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nstring_1 = \"Moses supposes his toeses are roses,\"\nstring_2 = \"Moses supposes erroneously.\"\n\nstring_1 + \", but \" + string_2\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n'Moses supposes his toeses are roses,, but Moses supposes erroneously.'\n```\n:::\n:::\n\n\nHowever, they cannot be subtracted, divided, or multiplied!\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nstring_1 - \"Moses\"\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n```\n:::\n:::\n\n\nMuch as we can subset *lists* and similar objects, we can also subset *strings* according to their *characters*:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nstring_1[0:5]\nstring_1[5:]\nstring_2[-12:-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n'erroneously'\n```\n:::\n:::\n\n\n:::{.callout-warning}\nA **list** of string objects is not the same as a standalone string object!  The *length* of a list is the number of *elements* it has.  The *length* of a string is the number of *characters* it has.\n\n:::\n\n:::{.callout-check-in .icon}\n\nWhat do you think the following code will return?\n\n``` {.python .cell-code}\nme = \"Kelly\"\nme_list = [\"Kelly\"]\n\nlen(me)\nlen(me_list)\nlen(me_list[0])\n```\n\n\n:::\n\n### Cleaning up a string\n\nWhat other changes might we commonly want to make to string objects?  Many of the tasks we might need to do are available in python as **string methods**.  Recall that a *method* is a special function that can work *only* on a certain object type or structure.\n\nFor example, I might want to turn my whole string into lowercase letters, perhaps for simplicity.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nstring_1.lower()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'moses supposes his toeses are roses,'\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\nWhat other string methods can you find for changing the *case* of the string?\n:::\n\nI also might want to get rid of any extra white space that is unnecessary:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nstring_3 = \"          doot de doo de doo     \"\nstring_3.strip()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n'doot de doo de doo'\n```\n:::\n:::\n\n\n### Searching and replacing\n\nPerhaps we want to make changes to the contents of a string.  First, we might check to see if the word we want to change is truly present in the string:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nstring_4 = \"My name is Bond, James Bond.\"\nstring_4.find(\"Bond\")\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n11\n```\n:::\n:::\n\n\nNotice that this gives back the character index where the desired word *starts*.\n\nIf the pattern is not found, we get back a value of `-1`.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nstring_4.find(\"007\")\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n-1\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\nWhat happens if you replace `.find` with `.findall`?  When might it be better to use one, and when might it be better to use the other?\n:::\n\nNext, we can replace the word with a different string:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nstring_4.replace(\"Bond\", \"Earl Jones\")\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n'My name is Earl Jones, James Earl Jones.'\n```\n:::\n:::\n\n\n:::{.callout-warning}\nAs with any object, nothing changes permanently until we *reassign* the object.  The `.replace()` method did not alter the object `string_4`:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nstring_4\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n'My name is Bond, James Bond.'\n```\n:::\n:::\n\n\n:::\n\nSometimes, when we want to build up a particularly complex string, or repeat a string alteration with different values, it is more convenient to put a \"placeholder\" in the string using curly brackets `{}` and fill the space in later.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nstring_4 = \"My name is {}, James {}.\"\nstring_4.format(\"Bond\", \"Bond\")\nstring_4.format(\"Franco\", \"Franco\")\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n'My name is Franco, James Franco.'\n```\n:::\n:::\n\n\nThe `{}` placeholder combined with the `.format()` method also allows for named placeholders, which is handy when you want to repeat a value:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nstring_4 = \"My name is {lastname}, {firstname} {lastname}.\"\nstring_4.format(firstname = \"James\", lastname = \"Baldwin\")\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n'My name is Baldwin, James Baldwin.'\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\nRecall from the Chapter 7 check-ins that we wrote a function to sing the \"99 bottles of beer on the wall\" song with a new drink and container.  Rewrite this function using the `.format()` trick.\n\n``` {.python .cell-code}\ndef sing_verse_3(num, drink, container):\n  song = str(num) + \" \" + container +\" of \" + drink + \" on the wall \\n\"\n  song = song + str(num) + \" \"+ container +\" of \" + drink + \"\\n\" \n  song = song + \" take one down, pass it around, \\n\"\n  song = song + str(num-1) + container + \" of \" + drink + \" on the wall \\n\"\n  \n  return song\n```\n\n\n:::\n\n### Splitting and joining\n\nSometimes, it may be convenient to convert our strings into lists of strings, or back into one single string object.\n\nTo turn a long string into a list, we **split** the string:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nfish_string = \"One fish, two fish, red fish, blue fish.\"\nfish_list = fish_string.split(\", \")\nfish_list\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n['One fish', 'two fish', 'red fish', 'blue fish.']\n```\n:::\n:::\n\n\nNotice that our argument to the `.split()` was the pattern we wanted to split on - in this case, every time there was a comma and a space.  The characters used for splitting are removed, and each remaining section becomes an object in the list.\n\nNow that we have a list, if we want to use string methods, we can't apply them directly to the list object:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfish_list.replace(\"fish\", \"moose\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nAttributeError: 'list' object has no attribute 'replace'\n```\n:::\n:::\n\n\nInstead, we'll need to *iterate* over the string objects in the list.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nnew_list = list(map(lambda x: x.replace(\"fish\", \"moose\"), fish_list))\n\nnew_list\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n['One moose', 'two moose', 'red moose', 'blue moose.']\n```\n:::\n:::\n\n\nNow, if we want to recombine this list into one string, we will **join** all its elements together.  The `.join()` method is a bit of a peculiar construct: we call the method on a string that we want to put *between* each list element when we bring them together.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n\" and \".join(new_list)\n\", \".join(new_list)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n'One moose, two moose, red moose, blue moose.'\n```\n:::\n:::\n\n\n## Regular Expressions\n\nIn the `.replace()` method above, we supplied the exact pattern that we wanted to replace in the string.\n\nBut what if we wanted to find or replace all *approximate* matches?  For example, if we have the string\n\n``` {.python .cell-code}\nmoses_string = \"Moses supposes his toeses are roses, but Moses supposes erroneously.  Moses he knowses his toeses aren't roses, as Moses supposes his toeses to be.\"\n```\n\n\nwe might be interested in finding all the rhyming words in this string, i.e., all words ending in \"-oses\" or \"-oeses\".\n\nTo perform this kind of *fuzzy matching*, we need to use **regular expressions**.  \n\nA *regular expression* is a special type of string, that can be interpreted by particular functions as a series of commands for fuzzy matching.\n\nFor example, instead of using the `.findall()` string method, we'll use the very similar function `re.findall()` to search a string using regular expressions:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nimport re\nre.findall(r\"[Mr]oses\", moses_string)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n['Moses', 'roses', 'Moses', 'Moses', 'roses', 'Moses']\n```\n:::\n:::\n\n\nIn the above code, the `r` in front of the regular expression `\"[Mr]oses\"` let the function know a regular expression was being provided.  This isn't always needed, but it's a good habit to get into, to make it clear when you supplying an ordinary string (a.k.a. *string literal*) or a *regex*.\n\nThe `[Mr]` part of the regex told the `re.findall()` function to match any \"M\" **or** any \"r\" - so we were able to find instances of both \"Moses\" and \"roses\"!\n\nRegular expressions can be both very powerful and very frustrating.  With the right expression, you can match any complicated string bit you might want to search for in data!  But putting the expressions together requires learning the special characters that lead to fuzzy matching, such as knowing that something in brackets, like `[Mr]` means \"match either of these characters\".\n\n![](https://imgs.xkcd.com/comics/regular_expressions.png)\n\n### Shortcuts\n\nIn our Moses example, we wanted to match all rhyming words.  Rather than go through the whole string to figure out possible letters that come before \"-oses\", we can instead use the `\\w` regular expression shortcut to say \"match any character that might be found in a word\" - i.e., not punctuation or whitespace.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nre.findall(r\"\\woses\", moses_string)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n['Moses',\n 'poses',\n 'roses',\n 'Moses',\n 'poses',\n 'Moses',\n 'roses',\n 'Moses',\n 'poses']\n```\n:::\n:::\n\n\nOther handy shortcuts include:\n\n* `\\b`: \"boundary\" between word and non-word, such as punctuation or whitespace\n\n* `\\s` : \"space\" matches a single whitespace character \n\n* `\\d` : \"digit\" matches any single number 0-9 \n\n* `^` : matches the start of a string\n\n* `$` : matches the end of a string\n\n* `.` : matches any character at all, except a new line (`\\n`)\n\n:::{.callout-check-in .icon}\n\nConsider the following string:\n\n``` {.python .cell-code}\nnursery_rhyme = \"Peter Piper picked a peck of pickled peppers, A peck of pickled peppers Peter Piper picked; If Peter Piper picked a peck of pickled peppers, Whereâ€™s the peck of pickled peppers Peter Piper picked?\"\n```\n\n\n1. Use `re.split()` and a regular expression to turn this into a list where each element is one word.\n\n2. Find all the words that start with the letter p.\n\n:::\n\n\n### Repetition\n\nWe still haven't quite completed our goal of finding the rhyming words, because we were only able to match the string \"poses\" instead of the full word \"supposes\".\n\nAn important set of special symbols in regular expressions are those that control how *many* of a particular character to look for.  For example,\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nnames = \"Key, Kely, Kelly, Kellly, Kelllly\"\nre.findall(r\"Kel+y\", names)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n['Kely', 'Kelly', 'Kellly', 'Kelllly']\n```\n:::\n:::\n\n\nIn this regex, the `+` character means \"match the previous thing at least one time\".  Since the thing before the `+` is the letter `l`, we match any string that starts with \"Ke\", then has one or more l's, then has a y.\n\nOther regex symbols for repetition are:\n\n* `*` : Match 0 or more of the previous character\n\n* `?` : Match 0 or one of the previous character\n\n* `{2}` : Match exactly two of the previous character\n\n* `{1,3}`: Match 1 to 3 repeats of the previous character\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nre.findall(r\"Kel*y\", names)\nre.findall(r\"Kel?y\", names)\nre.findall(r\"Kel{2}y\", names)\nre.findall(r\"Kel{2,3}y\", names)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n['Kelly', 'Kellly']\n```\n:::\n:::\n\n\n:::{.callout-check-in}\nUse repetition to find **all** the rhyming words in the Moses rhyme.  \n\n*Hint: Don't forget \"toeses\"!  How can you make the \"e\" optional, to match either \"-oses\" or \"-oeses\"?*\n:::\n\n### Escaping special characters\n\nWith characters like `*` or `?` or `\\` being given special roles in a regular expression, you might wonder how to actually find these exact symbols in a string?\n\nThe answer is that we **escape** the character, by putting a `\\` in front of it:\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nstring_5 = \"Are you *really* happy?\"\nre.findall(r\"\\*\\w+\\*\", string_5) \n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n['*really*']\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\n\nThe following will read in the text of Bob Dylan's song *Blowing in the Wind*, which you can download [here](https://www.dropbox.com/scl/fi/8ju26x5m7toruua6n9uv6/wind_lyrics?rlkey=5hte64nnyg7cpt0m4pcxn6f8i&dl=1).\n\n``` {.python .cell-code}\nf = open('wind_lyrics.txt', 'r')\nwind = f.read()\nf.close()\n```\n\n\n1. How many questions does Dylan ask in the song?\n\n2. Can you extract these questions?\n\n*Hint: consider splitting the lyrics into a list of sentences, then finding which sentences are questions.*\n\n:::\n\n### Look-ahead and look-behind\n\nLastly, sometimes we want to match a piece of a string based on what comes *before* it.  For example, let's return one last time to Moses and his toeses.  To find all the verbs that Moses does, we want to find words that come *after* the word Moses:\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nre.findall(r\"(?<=Moses )\\w+\", moses_string)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n['supposes', 'supposes', 'he', 'supposes']\n```\n:::\n:::\n\n\nThe `(?<= )` part of the regex means \"don't actually match these characters, but look for them before our actual pattern\".  This is called a **look-behind**.\n\nOr, we can use `(?=)` to do a **look-ahead**:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nre.findall(r\"\\w+(?= Moses )\", moses_string)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n['but', 'as']\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\nIn *Blowin in the Wind*, what words follow the phrase \"how many\"?\n:::\n\n### Conclusion\n\n:::{.callout-warning}\nThe special symbols and structures for a regular expression are built into a programming language.  `python` uses what are called *perl-like* regular expressions, which are the most common in modern languages.  However, you may encounter other programming languages that use slightly different symbols to do various matching tasks!\n:::\n\n:::{.callout-practice-exercise .icon}\n[Click here](https://colab.research.google.com/drive/1St8h7dMLbbYf3vxtIUGwqoaT5Ld6AOy3?usp=sharing) to practice using regular expressions and string methods to decode a message.\n\n*Hint: You will need the `re.sub()` function for this task!*\n:::\n\n\n:::{.callout-opinion .icon}\nIf you, like me, think Regular Expressions are super fun, try out the [RegEx Crossword Puzzle](https://regexcrossword.com/).\n:::\n\n",
    "supporting": [
      "08-regex_files"
    ],
    "filters": [],
    "includes": {}
  }
}