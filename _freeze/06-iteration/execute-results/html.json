{
  "hash": "51701942c676cee0da4d5e012c33dc2e",
  "result": {
    "markdown": "---\ntitle: \"Iteration\"\n---\n\n\n\n## Introduction\n\nIn this chapter, we will learn strategies for **iteration**, or performing a repeated task over many values.\n\nConsider the following task:  Suppose I want to get a computer to print out the lyrics to the song [99 Bottles of Beer on the Wall](https://www.youtube.com/watch?v=FITjBet3dio).\n\nNow, we could certainly simply type up all the lyrics ourselves:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nprint(\n  \"99 Bottles of beer on the wall, 99 Bottles of beer. Take one down, pass it around, 98 Bottles of beer on the wall. 98 Bottles of beer on the wall, 98 Bottles of beer. Take one down, pass it around, 97 Bottles of beer on the wall.\" #... etc etc etc\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n99 Bottles of beer on the wall, 99 Bottles of beer. Take one down, pass it around, 98 Bottles of beer on the wall. 98 Bottles of beer on the wall, 98 Bottles of beer. Take one down, pass it around, 97 Bottles of beer on the wall.\n```\n:::\n:::\n\n\nThat sounds like... not much fun to do.  \n\nBut we notice that in the song, there is a ton of repetition!  Every verse is almost identical, except for the number of bottles of beer.\n\nThis is a great time for some *iteration*.\n\n:::{.callout-opinion .icon collapse=\"true\"}\nFortunately, we aren't going to try to sing this version: https://www.youtube.com/watch?v=R30DnFfVtUw\n:::\n\n\n## For loops\n\nThe most basic approach to iteration is a simple `for` loop.  At each step of the loop the value of our placeholder, `i`, changes to the next step in the provided list, `range(100,97,-1)`.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nfor i in range(100,97,-1):\n  print(str(i) + \" bottles of beer on the wall\")\n  print(str(i) + \" bottles of beer\")\n  print(\" take one down, pass it around,\")\n  print(str(i-1) + \" bottles of beer on the wall\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100 bottles of beer on the wall\n100 bottles of beer\n take one down, pass it around,\n99 bottles of beer on the wall\n99 bottles of beer on the wall\n99 bottles of beer\n take one down, pass it around,\n98 bottles of beer on the wall\n98 bottles of beer on the wall\n98 bottles of beer\n take one down, pass it around,\n97 bottles of beer on the wall\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\n\nAfter last chapter, hopefully we immediately see that this is a great opportunity to write a function, to make our code clearer and avoid repetition.\n\nWrite a function called `sing_verse()` to replace the body of the `for` loop.\n\n:::\n\n:::{.callout-check-in .icon collapse=\"true\"}\n\n``` {.python .cell-code}\ndef sing_verse(num):\n  song = str(num) + \" bottles of beer on the wall \\n\" + str(num) + \" bottles of beer \\n\" + \" take one down, pass it around, \\n\" + str(num-1) + \" bottles of beer on the wall \\n\"\n  \n  return song\n```\n\n\n:::\n\nNotice that in this function, instead of `print`-ing out the lines of the song, we return the an object consisting as one long string.\n\nOften, when running a `for` loop, you want to end the loop process with a single object.  To do this, we start with an empty object, and then add to it at each loop.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nsong = \"\"\n\nfor i in range(100,97,-1):\n  song = song + sing_verse(i)\n  \nprint(song)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100 bottles of beer on the wall \n100 bottles of beer \n take one down, pass it around, \n99 bottles of beer on the wall \n99 bottles of beer on the wall \n99 bottles of beer \n take one down, pass it around, \n98 bottles of beer on the wall \n98 bottles of beer on the wall \n98 bottles of beer \n take one down, pass it around, \n97 bottles of beer on the wall \n\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\nModify the code above so that instead of creating one long string, we create a *list*, where each element is one of the verses of the song.\n:::\n\n### Vectorized functions\n\nThe function that we wrote above can be described as **not vectorized**.  What we mean by that it is designed to only take one value, `num`.  If we instead try to input a list or vector of numbers, we get an error:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nsing_verse([100,99,98])\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: unsupported operand type(s) for -: 'list' and 'int'\n```\n:::\n:::\n\n\nThis is why, in order to get results for a list of number, we needed to iterate.\n\nHowever, plenty of functions are designed to work well for single numbers *or* lists and vectors.  For example:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\na_num = 5\na_vec = [1,3,5,7]\n\nnp.sqrt(a_num)\nnp.sqrt(a_vec)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([1.        , 1.73205081, 2.23606798, 2.64575131])\n```\n:::\n:::\n\n\nWhen we want to perform a function over many values - whether it's one we wrote or not - we first need to ask ourselves if the function is vectorized or not.  Using a `for` loop over a vectorized function is unnecessarily complicated and computationally slow!\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nresult = []\nfor i in a_vec:\n  result = result + [np.sqrt(i)]\n  \nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n[1.0, 1.7320508075688772, 2.23606797749979, 2.6457513110645907]\n```\n:::\n:::\n\n\n### Vectorizing and booleans\n\nA common reason why a custom function is written in an unvectorized way is that it makes use of `if` statements.  For example, consider the task of taking the square root of only the *positive* numbers in a list.\n\nHere is an approach that *does not* work:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\na_vec = np.array([-2, 1, -3, -9, 7])\n\nif a_vec > 0:\n  a_vec = np.sqrt(a_vec)\n\na_vec\n```\n\n::: {.cell-output .cell-output-error}\n```\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n```\n:::\n:::\n\n\nThe statement `if a_vec > 0` makes no sense for a vector!  The `if` statement needs either a single `True` or a single `False` to determine if the subsequent code will be run - but `a_vec > 0` returns a list of five booleans.\n\nInstead, we would need to iterate over the values:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\na_vec = np.array([-2, 1, -3, -9, 7])\n\nfor val in a_vec:\n  if val > 0:\n    val = np.sqrt(val)\n  print(val)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-2\n1.0\n-3\n-9\n2.6457513110645907\n```\n:::\n:::\n\n\nHowever, there is a nicer approach to this variety of problem, which is to use **boolean masking**:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nis_pos = a_vec > 0\n\na_vec[is_pos] = np.sqrt(a_vec[is_pos])\n\na_vec\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([-2,  1, -3, -9,  2])\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\n\nWrite two functions:\n\n* `sqrt_pos_unvec()` takes in a single value as an argument, and returns the square root if the value is positive.  Then, write a `for` loop that uses this function to construct a new vector where the positive values are square rooted.\n\n* `sqrt_pos_vec()` takes in a vector of values, and returns a vector with the positive values square rooted.  **Do not** use a for loop inside your function.\n\n:::\n\n\n## Iterable functions \n\nAlthough `for` loops are a clear and basic procedure, it can become very tedious to use them frequently.  This is especially true if you want to save the results of the iteration as a new object.\n\nHowever, it will not be possible or convenient to write every function in a vectorized way.\n\nInstead, we can use **iterable functions**, which perform the same iteration as a `for` loop in shorter and more elegant code.\n\n### `map()`\n\nThe `map()` function requires the same information as a `for` loop: what values we want to iterate over, and what we want to do with each value.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nsong = map(sing_verse, range(100, 97, -1))\nsong = list(song)\nprint(\"\".join(song))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100 bottles of beer on the wall \n100 bottles of beer \n take one down, pass it around, \n99 bottles of beer on the wall \n99 bottles of beer on the wall \n99 bottles of beer \n take one down, pass it around, \n98 bottles of beer on the wall \n98 bottles of beer on the wall \n98 bottles of beer \n take one down, pass it around, \n97 bottles of beer on the wall \n\n```\n:::\n:::\n\n\n:::{.callout-note}\nNotice that the output of the `map()` function is a special object structure, of the type \"map object\".  We automatically convert this to a list with the `list()` function.\n\nThen, we make use of the `join()` string method to turn the list into one long string.  Finally, we `print()` our final string out so that it looks nice.\n:::\n\n#### Double mapping\n\nSometimes, we want to loop through multiple sets of values at once.  The `map()` function has the ability to take as many *iterables*, or lists of values, as you want.\n\nSuppose we want to change our `sing_verse()` function so that it has two arguments, the number of bottles and the type of drink.\n\n``` {.python .cell-code}\ndef sing_verse_2(num, drink):\n  song = str(num) + \" bottles of \" + drink + \" on the wall \\n\"\n  song = song + str(num) + \" bottles of \" + drink + \"\\n\" \n  song = song + \" take one down, pass it around, \\n\"\n  song = song + str(num-1) + \" bottles of \" + drink + \" on the wall \\n\"\n  \n  return song\n```\n\n\nNow, we use `map()` to switch the number *and* the drink at each iteration:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nnums = range(100, 97, -1)\ndrinks = [\"beer\", \"milk\", \"lemonade\"]\nsong = map(sing_verse_2, nums, drinks)\nprint(\"\".join(list(song)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100 bottles of beer on the wall \n100 bottles of beer\n take one down, pass it around, \n99 bottles of beer on the wall \n99 bottles of milk on the wall \n99 bottles of milk\n take one down, pass it around, \n98 bottles of milk on the wall \n98 bottles of lemonade on the wall \n98 bottles of lemonade\n take one down, pass it around, \n97 bottles of lemonade on the wall \n\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\n\nWrite a `sing_verse_3()` function that also lets us change the container (e.g. bottle, can, ...) at each step of the loop.\n\nUse `map()` to sing a few verses.\n\nWhat happens if you supply three different drinks, but only two different types of containers?\n\n:::\n\n## Lambda functions\n\nWhat would you do if you still wanted to count down the number of bottles, but you wanted them all to be lemonade?\n\nIn this case, we want *one* of the arguments of our function to be iterated over many values, and the other one to stay consistent.\n\nOne rather inelegant way we could accomplish this is with a new function:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef sing_verse_lemonade(num):\n  return sing_verse_2(num, \"lemonade\")\n\nsong = map(sing_verse_lemonade, nums)\nprint(\"\".join(list(song)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100 bottles of lemonade on the wall \n100 bottles of lemonade\n take one down, pass it around, \n99 bottles of lemonade on the wall \n99 bottles of lemonade on the wall \n99 bottles of lemonade\n take one down, pass it around, \n98 bottles of lemonade on the wall \n98 bottles of lemonade on the wall \n98 bottles of lemonade\n take one down, pass it around, \n97 bottles of lemonade on the wall \n\n```\n:::\n:::\n\n\nThis is a lot of extra lines of code, though, for a task that should be straightforward - and we'll probably never use `sing_verse_lemonade()` again, so it's a bit of a waste to create it.\n\nInstead, we will use what is called a **lambda function**, which is like making a new `sing_verse_lemonade` wrapper function for temporary use:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nsong = map(lambda i: sing_verse_2(i, \"lemonade\"), nums)\nprint(\"\".join(list(song)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n100 bottles of lemonade on the wall \n100 bottles of lemonade\n take one down, pass it around, \n99 bottles of lemonade on the wall \n99 bottles of lemonade on the wall \n99 bottles of lemonade\n take one down, pass it around, \n98 bottles of lemonade on the wall \n98 bottles of lemonade on the wall \n98 bottles of lemonade\n take one down, pass it around, \n97 bottles of lemonade on the wall \n\n```\n:::\n:::\n\n\nThe code `lambda i: sing_verse_2(i, \"lemonade\")` made a new **anonymous function** - sometimes called a **headless function** - that takes in one argument, `i`, and sends that argument into `sing_verse_2`.\n\n:::{.callout-check-in .icon}\nUse a lambda function with `sing_verse_3()` to sing a few verses about milk in glasses.\n:::\n\n\n\n## Iterating on datasets\n\nThis task of repeating a calculation with many inputs has a natural application area: datasets!\n\nIt is extremely common that we want to perform some calculation involving many *variables* of the dataset, and we want to repeat that same calculation over the values in each row.\n\nFor this situation, we use an iterable function that is very similar to `map()`: the `.apply()` method from `pandas`.\n\nAt its core, the `.apply()` method is meant for repeating a calculation over *columns*:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndat = pd.DataFrame({\"x\": [99, 50, 2], \"y\": [1, 2, 3]})\n\ndat.apply(np.sqrt)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>x</th>\n      <th>y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>9.949874</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>7.071068</td>\n      <td>1.414214</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1.414214</td>\n      <td>1.732051</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIn this chapter, though, we are more interested in using it to repeat a function, using each row as input:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndat.apply(np.sum, axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n0    100\n1     52\n2      5\ndtype: int64\n```\n:::\n:::\n\n\nSuppose we have a `pandas` dataframe consisting of all the numbers, drinks, and containers that we are interested in singing about:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndat = pd.DataFrame({\"num\": [99, 50, 2], \"drink\": [\"beer\", \"soda\", \"Capri Sun\"], \"container\": [\"bottles\", \"cans\", \"pouches\"]})\n\ndat\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>num</th>\n      <th>drink</th>\n      <th>container</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>99</td>\n      <td>beer</td>\n      <td>bottles</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>50</td>\n      <td>soda</td>\n      <td>cans</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>Capri Sun</td>\n      <td>pouches</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nOur goal is to **apply** the `sing_verse_3` function over all these *combinations* of values.\n\nUnfortunately, this doesn't happen automatically:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ndat.apply(sing_verse_3, axis=1)\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: sing_verse_3() missing 2 required positional arguments: 'drink' and 'container'\n```\n:::\n:::\n\n\nThis is because `.apply` doesn't \"know\" which columns below with which arguments of the `sing_verse_3` function.  We'll need to use a lambda function to help it out:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ndat.apply(lambda x: sing_verse_3(x['num'], x['drink'], x['container']), axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n0    99 bottles of beer on the wall \\n99 bottles of...\n1    50 cans of soda on the wall \\n50 cans of soda\\...\n2    2 pouches of Capri Sun on the wall \\n2 pouches...\ndtype: object\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\n[Click here to open the practice activity.](https://colab.research.google.com/drive/1vJH9g4APzXCgts5pmkn9v7F4gKU5wV1n?usp=sharing)\n:::\n\n",
    "supporting": [
      "06-iteration_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}