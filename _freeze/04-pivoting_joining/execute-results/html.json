{
  "hash": "86bf45eda796fe9083c4186c97ef32ee",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Pivoting and Joining\"\n---\n\n## Introduction\n\nThis document demonstrates the use of the `pandas` library in Python to do pivoting and joining of datasets.\n\n::: callout-note\nIf you do not have the `pandas` library installed then you will need to run\n\n`pip install pandas`\n\nin the Jupyter terminal to install. **Remember:** you only need to install once per machine (or Colab session).\n:::\n\n::: {#418ad175 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n```\n:::\n\n\n::: {#5c1a94de .cell execution_count=2}\n``` {.python .cell-code}\n# Population data from GapMinder\npopulation = pd.read_csv(\"/content/pop.csv\")\n```\n:::\n\n\n## Pivoting Data in Python\n\nData come in all shapes and forms! Rare is the day when we can open a dataset for the first time and it's ready for every type of visualization or analysis that we could want to do with it.\n\nIn addition to the wrangling we discussed in the previous chapter, there may be a need to reshape the dataset entirely. For example, the column names might be values themselves that we want to make use of.\n\nRecall our introduction of *tidy* data in the previous chapter...\n\n### Tidy Data is Special Tabular Data\n\nFor most people, the image that comes to mind when thinking about data is indeed something tabular or spreadsheet-like in nature. **Which is great!**\n\nTabular data is a form preferred by MANY different data operations and work. However, we will want to take this one step further. In almost all data science work we want our data to be **tidy**\n\n:::{.callout-note}\n\nA dataset is **tidy** if it adheres to following three characteristics:\n\n* Every column is a variable\n\n* Every row is an observation\n\n* Every cell is a single value\n\n:::\n\n![](https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png)\n\nIn the previous chapter you were asked to open up a GapMinder dataset [here](https://www.gapminder.org/data/) and to comment on whether this dataset was *tidy* or not.\nThe answer was **no**, this dataset is not *tidy*. These datasets come with a row representing a country, each column representing a year, and each cell representing the value of the global indicator selected. To be *tidy* these three variables (`country`, `year`, `global indicator`) should each have their own column, instead of the `year` variable taking values as the column headers.\n\n### Wide to Long Format\n\nThe GapMinder dataset is an example of what's commonly referred to as data in a *wide format*. To make this dataset *tidy* we aim for a dataset with columns for `country`, `year`, and `global indicator` (e.g. population). Three columns is many fewer than the current number of columns, and so we will convert this dataset from *wide to long format*.\n\n:::{.callout-warning}\n\nIt often helps to physically draw/map out what our current dataset looks like and what the look of our target dataset is, before actually trying to write any code to do this. Writing the code can be **extremely** easier after this exercise, and only makes future pivot operations easier.\n\n:::\n\nIn order to convert our dataset from *wide to long format* we will use `.melt()` (or `.wide_to_long()`) in `pandas`.\n\n::: {#329de024 .cell execution_count=3}\n``` {.python .cell-code}\nlong_population = population.melt(id_vars=[\"country\"], var_name=\"year\", value_name=\"population\")\n```\n:::\n\n\n:::{.callout-check-in .icon}\n\nWith 2-3 people around you navigate to GapMinder, download the population dataset, and convert it from wide to long format. Does the result look how you expect? Is any other wrangling necessary?\n\n:::\n\n### Long to Wide Format\n\nEven though certain data shapes are not considered *tidy*, they may be more conducive to performing certain operations than other shapes. For example, what if we were interested in the change in country population between 1950 and 2010? In the original *wide* shape of the GapMinder data this operation would have been a simple difference of columns like below.\n\n::: {#2a71fcf7 .cell execution_count=4}\n``` {.python .cell-code}\npopulation[\"pop_diff\"] = population[\"2010\"] - population[\"1950\"]\n```\n:::\n\n\n:::{.callout-check-in .icon}\n\nWhy doesn't the above code work without further wrangling? What in the dataset needs to change for this operation to work?\n\n:::\n\nIn the *long* format of our Gapminder dataset (`long_population`), this operation is less straightforward. Sometimes datasets come to us in *long* format and to do things like the operation above we need to convert that dataset from *long to wide format*. We can go the reverse direction (i.e. *long to wide format*) with `.pivot()` in `pandas`.\n\n::: {#00ab953a .cell execution_count=5}\n``` {.python .cell-code}\nwide_population = long_population.pivot(index = \"country\", columns = \"year\", values = \"population\")\nwide_population = wide_population.reset_index()\n```\n:::\n\n\n:::{.callout-learn-more .icon collapse=\"true\"}\n\nWe haven't spent much time discussing the `index` of a `pandas` DataFrame, but you can think of it like an address for data, or slices of data in a DataFrame. You can also think of an `index` (or `indices`) as row names, or axis labels, for your dataset. This can be useful for a number of functions in Python, and can enhance the look of results or visualizations.\n\nHowever, understanding them is not critical for what we will do in Python. Furthermore, variables that are `indices` for a DataFrame cannot be accessed or referenced in the same way as other variables in the DataFrame. So, we will avoid their use if possible.\n\n:::\n\n## Joining Datasets in Python\n\nThe information you need is often spread across multiple data sets, so you will need to combine multiple data sets into one. In this chapter, we discuss strategies for combining information from multiple (tabular) data sets.\n\nAs a working example, we will use a data set of baby names collected by the Social Security Administration. Each data set in this collection contains the names of all babies born in the United States in a particular year. This data is publicly available, and a copy has been made available at [https://dlsun.github.io/pods/data/names/](https://dlsun.github.io/pods/data/names/).\n\n### Concatenating and Merging Data\n\n#### Concatenation\n\nSometimes, the *rows* of data are spread across multiple files, and we want to combine the rows into a single data set. The process of combining rows from different data sets is known as concatenation.\n\nVisually, to concatenate two `DataFrames`, we simply stack them on top of one another.\n\nFor example, suppose we want to understand how the popularity of different names evolved between 1995 and 2015. The 1995 names and the 2015 names are stored in two different files: `yob1995.txt` and `yob2015.txt`, respectively. To carry out this analysis, we will need to combine these two data sets into one.\n\n::: {#37b2ee73 .cell execution_count=6}\n``` {.python .cell-code}\ndata_dir = \"http://dlsun.github.io/pods/data/names/\"\nnames1995 = pd.read_csv(data_dir + \"yob1995.txt\",\n                        header=None,\n                        names=[\"Name\", \"Sex\", \"Count\"])\nnames1995\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessica</td>\n      <td>F</td>\n      <td>27935</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ashley</td>\n      <td>F</td>\n      <td>26603</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Samantha</td>\n      <td>F</td>\n      <td>21646</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Sarah</td>\n      <td>F</td>\n      <td>21369</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>26075</th>\n      <td>Zerek</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>26076</th>\n      <td>Zhen</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>26077</th>\n      <td>Ziggy</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>26078</th>\n      <td>Zuberi</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>26079</th>\n      <td>Zyon</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n<p>26080 rows Ã— 3 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {#a5612a82 .cell execution_count=7}\n``` {.python .cell-code}\nnames2015 = pd.read_csv(data_dir + \"yob2015.txt\",\n                        header=None,\n                        names=[\"Name\", \"Sex\", \"Count\"])\nnames2015\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Emma</td>\n      <td>F</td>\n      <td>20455</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Olivia</td>\n      <td>F</td>\n      <td>19691</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Sophia</td>\n      <td>F</td>\n      <td>17417</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Ava</td>\n      <td>F</td>\n      <td>16378</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Isabella</td>\n      <td>F</td>\n      <td>15617</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>33116</th>\n      <td>Zykell</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>33117</th>\n      <td>Zyking</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>33118</th>\n      <td>Zykir</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>33119</th>\n      <td>Zyrus</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>33120</th>\n      <td>Zyus</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n<p>33121 rows Ã— 3 columns</p>\n</div>\n```\n:::\n:::\n\n\nTo concatenate the two, we use the `pd.concat()` function, which accepts a *list* of `pandas` objects (`DataFrames` or `Series`) and concatenates them.\n\n::: {#bcfd0354 .cell execution_count=8}\n``` {.python .cell-code}\npd.concat([names1995, names2015])\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessica</td>\n      <td>F</td>\n      <td>27935</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ashley</td>\n      <td>F</td>\n      <td>26603</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Samantha</td>\n      <td>F</td>\n      <td>21646</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Sarah</td>\n      <td>F</td>\n      <td>21369</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>33116</th>\n      <td>Zykell</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>33117</th>\n      <td>Zyking</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>33118</th>\n      <td>Zykir</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>33119</th>\n      <td>Zyrus</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>33120</th>\n      <td>Zyus</td>\n      <td>M</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n<p>59201 rows Ã— 3 columns</p>\n</div>\n```\n:::\n:::\n\n\n1. There is no longer any way to distinguish the 1995 data from the 2015 data. To fix this, we can add a **Year** column to each `DataFrame` before we concatenate.\n\n2. The indexes from the original `DataFrames` are preserved in the concatenated `DataFrame`. (To see this, observe that the last index in the `DataFrame` is about 33000, which corresponds to the number of rows in `names2015`, even though there are 59000 rows in the `DataFrame`.) That means that there are two rows with an index of 0, two rows with an index of 1, and so on. To force `pandas` to generate a completely new index for this `DataFrame`, ignoring the indices from the original `DataFrames`, we specify `ignore_index=True`.\n\n::: {#07fa374b .cell execution_count=9}\n``` {.python .cell-code}\nnames1995[\"Year\"] = 1995\nnames2015[\"Year\"] = 2015\nnames = pd.concat([names1995, names2015], ignore_index=True)\nnames\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count</th>\n      <th>Year</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessica</td>\n      <td>F</td>\n      <td>27935</td>\n      <td>1995</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ashley</td>\n      <td>F</td>\n      <td>26603</td>\n      <td>1995</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378</td>\n      <td>1995</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Samantha</td>\n      <td>F</td>\n      <td>21646</td>\n      <td>1995</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Sarah</td>\n      <td>F</td>\n      <td>21369</td>\n      <td>1995</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>59196</th>\n      <td>Zykell</td>\n      <td>M</td>\n      <td>5</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>59197</th>\n      <td>Zyking</td>\n      <td>M</td>\n      <td>5</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>59198</th>\n      <td>Zykir</td>\n      <td>M</td>\n      <td>5</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>59199</th>\n      <td>Zyrus</td>\n      <td>M</td>\n      <td>5</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>59200</th>\n      <td>Zyus</td>\n      <td>M</td>\n      <td>5</td>\n      <td>2015</td>\n    </tr>\n  </tbody>\n</table>\n<p>59201 rows Ã— 4 columns</p>\n</div>\n```\n:::\n:::\n\n\nNow this is a `DataFrame` we can use!\n\n#### Merging (a.k.a Joining)\n\nMore commonly, the data sets that we want to combine actually contain different information about the same observations. In other words, instead of stacking the `DataFrames` on top of each other, as in concatenation, we want to stack them next to each other. The process of combining columns or variables from different data sets is known as *merging* or *joining*.\n\nThe observations may be in a different order in the two data sets, so merging is not as simple as placing the two `DataFrames` side-by-side.\n\n*Merging* is an operation on two `DataFrames` that returns a third `DataFrame`. By convention, the first `DataFrame` is referred to as the one on the \"left\", while the second `DataFrame` is the one on the \"right\".\n\nThis naming convention is reflected in the syntax of the `.merge()` function in `pandas`. In the code below, the \"left\" `DataFrame`, `names1995`, is quite literally on the left in the code, while the \"right\" `DataFrame`, `names2015`, is to the right. We also specify the variables to match across the two `DataFrames`.\n\n::: {#457a2337 .cell execution_count=10}\n``` {.python .cell-code}\nnames1995.merge(names2015, on=[\"Name\", \"Sex\"])\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count_x</th>\n      <th>Year_x</th>\n      <th>Count_y</th>\n      <th>Year_y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessica</td>\n      <td>F</td>\n      <td>27935</td>\n      <td>1995</td>\n      <td>1587</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ashley</td>\n      <td>F</td>\n      <td>26603</td>\n      <td>1995</td>\n      <td>3424</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378</td>\n      <td>1995</td>\n      <td>11786</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Samantha</td>\n      <td>F</td>\n      <td>21646</td>\n      <td>1995</td>\n      <td>5340</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Sarah</td>\n      <td>F</td>\n      <td>21369</td>\n      <td>1995</td>\n      <td>4521</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>15675</th>\n      <td>Zephan</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>23</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15676</th>\n      <td>Zeppelin</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>70</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15677</th>\n      <td>Zerek</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>5</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15678</th>\n      <td>Ziggy</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>44</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15679</th>\n      <td>Zyon</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>148</td>\n      <td>2015</td>\n    </tr>\n  </tbody>\n</table>\n<p>15680 rows Ã— 6 columns</p>\n</div>\n```\n:::\n:::\n\n\nThe **most important component** of *merging* two datasets is the presence of at least one *key* variable that both datasets share. This variable is sometimes referred to as an *ID variable*. It's this variable that we will want to *merge on*, i.e. use to combine the two datasets intelligently.\n\nThe variables that we joined on (`Name` and `Sex`) appear once in the final `DataFrame`. The variable `Count`, which we did not join on, appears twice---since there was a column called `Count` in both of the original `DataFrames`. Notice that `pandas` automatically appended the suffix `_x` to the name of the variable from the left `DataFrame` and `_y` to the one from the right `DataFrame`. We can customize the suffixes by specifying the `suffixes=` parameter.\n\n::: {#b5bcdfb3 .cell execution_count=11}\n``` {.python .cell-code}\nnames1995.merge(names2015, on=[\"Name\", \"Sex\"], suffixes=(\"1995\", \"2015\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count1995</th>\n      <th>Year1995</th>\n      <th>Count2015</th>\n      <th>Year2015</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessica</td>\n      <td>F</td>\n      <td>27935</td>\n      <td>1995</td>\n      <td>1587</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ashley</td>\n      <td>F</td>\n      <td>26603</td>\n      <td>1995</td>\n      <td>3424</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378</td>\n      <td>1995</td>\n      <td>11786</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Samantha</td>\n      <td>F</td>\n      <td>21646</td>\n      <td>1995</td>\n      <td>5340</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Sarah</td>\n      <td>F</td>\n      <td>21369</td>\n      <td>1995</td>\n      <td>4521</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>15675</th>\n      <td>Zephan</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>23</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15676</th>\n      <td>Zeppelin</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>70</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15677</th>\n      <td>Zerek</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>5</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15678</th>\n      <td>Ziggy</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>44</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15679</th>\n      <td>Zyon</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>148</td>\n      <td>2015</td>\n    </tr>\n  </tbody>\n</table>\n<p>15680 rows Ã— 6 columns</p>\n</div>\n```\n:::\n:::\n\n\nIn the code above, we assumed that the columns that we joined on had the same names in the two data sets. What if they had different names? For example, suppose the variable had been called `Sex` in one data set and `Gender` in the other. We can specify which variables to use from the left and right data sets using the `left_on=` and `right_on=` parameters.\n\n::: {#c1745452 .cell execution_count=12}\n``` {.python .cell-code}\n# Create new DataFrames where the column names are different\nnames2015_ = names2015.rename({\"Sex\": \"Gender\"}, axis=1)\n\n# This is how you merge them.\nnames1995.merge(\n    names2015_,\n    left_on=(\"Name\", \"Sex\"),\n    right_on=(\"Name\", \"Gender\")\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count_x</th>\n      <th>Year_x</th>\n      <th>Gender</th>\n      <th>Count_y</th>\n      <th>Year_y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessica</td>\n      <td>F</td>\n      <td>27935</td>\n      <td>1995</td>\n      <td>F</td>\n      <td>1587</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ashley</td>\n      <td>F</td>\n      <td>26603</td>\n      <td>1995</td>\n      <td>F</td>\n      <td>3424</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378</td>\n      <td>1995</td>\n      <td>F</td>\n      <td>11786</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Samantha</td>\n      <td>F</td>\n      <td>21646</td>\n      <td>1995</td>\n      <td>F</td>\n      <td>5340</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Sarah</td>\n      <td>F</td>\n      <td>21369</td>\n      <td>1995</td>\n      <td>F</td>\n      <td>4521</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>15675</th>\n      <td>Zephan</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>M</td>\n      <td>23</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15676</th>\n      <td>Zeppelin</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>M</td>\n      <td>70</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15677</th>\n      <td>Zerek</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>M</td>\n      <td>5</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15678</th>\n      <td>Ziggy</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>M</td>\n      <td>44</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>15679</th>\n      <td>Zyon</td>\n      <td>M</td>\n      <td>5</td>\n      <td>1995</td>\n      <td>M</td>\n      <td>148</td>\n      <td>2015</td>\n    </tr>\n  </tbody>\n</table>\n<p>15680 rows Ã— 7 columns</p>\n</div>\n```\n:::\n:::\n\n\n#### One-to-One and Many-to-One Relationships\n\nIn the example above, there was at most one combination of `Name` and `Sex` in the 2015 data set for each combination of `Name` and `Sex` in the 1995 data set. These two data sets are thus said to have a one-to-one relationship. The same would be true of combining two GapMinder datasets.\n\nHowever, two data sets need not have a one-to-one relationship! Two datasets could have a *many-to-one relationship*. In general, it's **extremely important** to think carefully about what variables each of your two datasets have to begin with, and what variables you want your merged dataset to have...and what that merged dataset will represent with respect to your data.\n\n#### Many-to-Many Relationships: A Cautionary Tale\n\nIt is also possible for multiple rows in the left `DataFrame` to match multiple rows in the right `DataFrame`. In this case, the two data sets are said to have a *many-to-many relationship*. Many-to-many joins can lead to misleading analyses, so it is important to exercise caution when working with many-to-many relationships.\n\nFor example, in the baby names data set, the `Name` variable is not uniquely identifying. For example, there are both males and females with the name \"Jessie\".\n\n::: {#1b6cc45e .cell execution_count=13}\n``` {.python .cell-code}\njessie1995 = names1995[names1995[\"Name\"] == \"Jessie\"]\njessie1995\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count</th>\n      <th>Year</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>248</th>\n      <td>Jessie</td>\n      <td>F</td>\n      <td>1138</td>\n      <td>1995</td>\n    </tr>\n    <tr>\n      <th>16047</th>\n      <td>Jessie</td>\n      <td>M</td>\n      <td>903</td>\n      <td>1995</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#31528988 .cell execution_count=14}\n``` {.python .cell-code}\njessie2015 = names2015[names2015[\"Name\"] == \"Jessie\"]\njessie2015\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count</th>\n      <th>Year</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>615</th>\n      <td>Jessie</td>\n      <td>F</td>\n      <td>469</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>20009</th>\n      <td>Jessie</td>\n      <td>M</td>\n      <td>233</td>\n      <td>2015</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIf we join these two `DataFrames` on `Name`, then we will end up with a many-to-many join, since each \"Jessie\" row in the 1995 data will be paired with each \"Jessie\" row in the 2015 data.\n\n::: {#1259c9d3 .cell execution_count=15}\n``` {.python .cell-code}\njessie1995.merge(jessie2015, on=[\"Name\"])\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex_x</th>\n      <th>Count_x</th>\n      <th>Year_x</th>\n      <th>Sex_y</th>\n      <th>Count_y</th>\n      <th>Year_y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessie</td>\n      <td>F</td>\n      <td>1138</td>\n      <td>1995</td>\n      <td>F</td>\n      <td>469</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Jessie</td>\n      <td>F</td>\n      <td>1138</td>\n      <td>1995</td>\n      <td>M</td>\n      <td>233</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Jessie</td>\n      <td>M</td>\n      <td>903</td>\n      <td>1995</td>\n      <td>F</td>\n      <td>469</td>\n      <td>2015</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Jessie</td>\n      <td>M</td>\n      <td>903</td>\n      <td>1995</td>\n      <td>M</td>\n      <td>233</td>\n      <td>2015</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNotice that Jessie ends up appearing four times:\n\n* Female Jessies from 1995 are matched with female Jessies from 2015. (Good!)\n* Male Jessies from 1995 are matched with male Jessies from 2015. (Good!)\n* Female Jessies from 1995 are matched with male Jessies from 2015. (This is perhaps undesirable.)\n* Male Jessies from 1995 are matched with female Jessies from 2015. (Also unexpected and undesirable.)\n\nIf we had used a data set like this to determine the number of Jessies in 1995, then we would end up with the wrong answer, since we would have double-counted both female and male Jessies as a result of the many-to-many join. This is why it is important to exercise caution when working with (potential) many-to-many relationships.\n\n### Types of Joins\n\nAbove, we saw how to merge (or join) two data sets by matching on certain variables. But what happens when a row in one `DataFrame` has no match in the other?\n\nFirst, let's investigate how `pandas` handles this situation by default. The name \"Nevaeh\", which is \"heaven\" spelled backwards, took after Sonny Sandoval of the band P.O.D. gave his daughter the name in 2000. Let's look at how common this name was five years earlier and five years after.\n\n::: {#6625a0f9 .cell execution_count=16}\n``` {.python .cell-code}\ndata_dir = \"http://dlsun.github.io/pods/data/names/\"\n\nnames1995 = pd.read_csv(data_dir + \"yob1995.txt\",\n                        header=None, names=[\"Name\", \"Sex\", \"Count\"])\nnames2005 = pd.read_csv(data_dir + \"yob2005.txt\",\n                        header=None, names=[\"Name\", \"Sex\", \"Count\"])\n```\n:::\n\n\n::: {#e8d19726 .cell execution_count=17}\n``` {.python .cell-code}\nnames1995[names1995.Name == \"Nevaeh\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#473e1693 .cell execution_count=18}\n``` {.python .cell-code}\nnames2005[names2005.Name == \"Nevaeh\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>68</th>\n      <td>Nevaeh</td>\n      <td>F</td>\n      <td>4552</td>\n    </tr>\n    <tr>\n      <th>21353</th>\n      <td>Nevaeh</td>\n      <td>M</td>\n      <td>56</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIn 1995, there were no girls (at least fewer than 5) named Nevaeh; just eight years later, there were over 4500 girls (and even 56 boys) with the name. It seems like Sonny Sandoval had a huge effect.\n\nWhat happens to the name \"Nevaeh\" when we merge the two data sets?\n\n::: {#2a653eca .cell execution_count=19}\n``` {.python .cell-code}\nnames = names1995.merge(names2005, on=[\"Name\", \"Sex\"])\nnames[names.Name == \"Nevaeh\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count_x</th>\n      <th>Count_y</th>\n    </tr>\n  </thead>\n  <tbody>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nBy default, `pandas` only includes combinations that are present in both `DataFrames`. If it cannot find a match for a row in one `DataFrame`, then the combination is simply dropped.\n\nBut in this context, the fact that a name does not appear in one data set is informative. It means that no babies were born in that year with that name. We might want to include names that appeared in only one of the two `DataFrames`, rather than just the names that appeared in both.\n\nThere are four types of joins, distinguished by whether they include the rows from the left `DataFrame`, the right `DataFrame`, both, or neither:\n\n1. *inner join* (default): only values that are present in both `DataFrames` are included in the result\n2. *outer join*: any value that appears in either `DataFrame` is included in the result\n3. *left join*: any value that appears in the left `DataFrame` is included in the result, whether or not it appears in the right `DataFrame`\n4. *right join*: any value that appears in the right `DataFrame` is included in the result, whether or not it appears in the left `DataFrame`.\n\nOne way to visualize the different types of joins is using Venn diagrams. The shaded region indicates which rows that are included in the output. For example, only rows that appear in both the left and right `DataFrames` are included in the output of an inner join.\n\n![](https://github.com/dlsun/pods/blob/master/09-Joining-Tabular-Data/joins.png?raw=1)\n\nIn `pandas`, the join type is specified using the `how=` argument.\n\nNow let's look at the examples of each of these types of joins.\n\n::: {#64389c7e .cell execution_count=20}\n``` {.python .cell-code}\n# inner join\nnames_inner = names1995.merge(names2005, on=[\"Name\", \"Sex\"], how=\"inner\")\nnames_inner\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count_x</th>\n      <th>Count_y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessica</td>\n      <td>F</td>\n      <td>27935</td>\n      <td>8108</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ashley</td>\n      <td>F</td>\n      <td>26603</td>\n      <td>13270</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378</td>\n      <td>23930</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Samantha</td>\n      <td>F</td>\n      <td>21646</td>\n      <td>13633</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Sarah</td>\n      <td>F</td>\n      <td>21369</td>\n      <td>11527</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>19119</th>\n      <td>Zeppelin</td>\n      <td>M</td>\n      <td>5</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>19120</th>\n      <td>Zerek</td>\n      <td>M</td>\n      <td>5</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>19121</th>\n      <td>Zhen</td>\n      <td>M</td>\n      <td>5</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>19122</th>\n      <td>Ziggy</td>\n      <td>M</td>\n      <td>5</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>19123</th>\n      <td>Zyon</td>\n      <td>M</td>\n      <td>5</td>\n      <td>102</td>\n    </tr>\n  </tbody>\n</table>\n<p>19124 rows Ã— 4 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {#1712bfdf .cell execution_count=21}\n``` {.python .cell-code}\n# outer join\nnames_outer = names1995.merge(names2005, on=[\"Name\", \"Sex\"], how=\"outer\")\nnames_outer\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count_x</th>\n      <th>Count_y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessica</td>\n      <td>F</td>\n      <td>27935.0</td>\n      <td>8108.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ashley</td>\n      <td>F</td>\n      <td>26603.0</td>\n      <td>13270.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378.0</td>\n      <td>23930.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Samantha</td>\n      <td>F</td>\n      <td>21646.0</td>\n      <td>13633.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Sarah</td>\n      <td>F</td>\n      <td>21369.0</td>\n      <td>11527.0</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>39490</th>\n      <td>Zymiere</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>39491</th>\n      <td>Zyrell</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>39492</th>\n      <td>Zyrian</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>39493</th>\n      <td>Zyshon</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>39494</th>\n      <td>Zytavious</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5.0</td>\n    </tr>\n  </tbody>\n</table>\n<p>39495 rows Ã— 4 columns</p>\n</div>\n```\n:::\n:::\n\n\nNames like \"Zyrell\" and \"Zyron\" appeared in the 2005 data but not the 1995 data. For this reason, their count in 1995 is `NaN`. In general, there will be missing values in `DataFrames` that result from an outer join. Any time a value appears in one `DataFrame` but not the other, there will be `NaN`s in the columns from the `DataFrame` missing that value.\n\n::: {#c882803e .cell execution_count=22}\n``` {.python .cell-code}\nnames_inner.isnull().sum()\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nName       0\nSex        0\nCount_x    0\nCount_y    0\ndtype: int64\n```\n:::\n:::\n\n\nLeft and right joins preserve data from one `DataFrame` but not the other. For example, if we were trying to calculate the percentage change for each name from 1995 to 2005, we would want to include all of the names that appeared in the 1995 data. If the name did not appear in the 2005 data, then that is informative.\n\n::: {#5e730aa9 .cell execution_count=23}\n``` {.python .cell-code}\n# left join\nnames_left = names1995.merge(names2005, on=[\"Name\", \"Sex\"], how=\"left\")\nnames_left\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count_x</th>\n      <th>Count_y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Jessica</td>\n      <td>F</td>\n      <td>27935</td>\n      <td>8108.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Ashley</td>\n      <td>F</td>\n      <td>26603</td>\n      <td>13270.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378</td>\n      <td>23930.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Samantha</td>\n      <td>F</td>\n      <td>21646</td>\n      <td>13633.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Sarah</td>\n      <td>F</td>\n      <td>21369</td>\n      <td>11527.0</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>26075</th>\n      <td>Zerek</td>\n      <td>M</td>\n      <td>5</td>\n      <td>8.0</td>\n    </tr>\n    <tr>\n      <th>26076</th>\n      <td>Zhen</td>\n      <td>M</td>\n      <td>5</td>\n      <td>7.0</td>\n    </tr>\n    <tr>\n      <th>26077</th>\n      <td>Ziggy</td>\n      <td>M</td>\n      <td>5</td>\n      <td>6.0</td>\n    </tr>\n    <tr>\n      <th>26078</th>\n      <td>Zuberi</td>\n      <td>M</td>\n      <td>5</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>26079</th>\n      <td>Zyon</td>\n      <td>M</td>\n      <td>5</td>\n      <td>102.0</td>\n    </tr>\n  </tbody>\n</table>\n<p>26080 rows Ã— 4 columns</p>\n</div>\n```\n:::\n:::\n\n\nThe result of the left join has `NaN`s in the columns from the right `DataFrame`.\n\n::: {#75f23b8d .cell execution_count=24}\n``` {.python .cell-code}\nnames_left.isnull().sum()\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nName          0\nSex           0\nCount_x       0\nCount_y    6956\ndtype: int64\n```\n:::\n:::\n\n\nThe result of the right join, on the other hand, has `NaN`s in the column from the left `DataFrame`.\n\n::: {#9f1eca4c .cell execution_count=25}\n``` {.python .cell-code}\n# right join\nnames_right = names1995.merge(names2005, on=[\"Name\", \"Sex\"], how=\"right\")\nnames_right\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Sex</th>\n      <th>Count_x</th>\n      <th>Count_y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Emily</td>\n      <td>F</td>\n      <td>24378.0</td>\n      <td>23930</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Emma</td>\n      <td>F</td>\n      <td>5041.0</td>\n      <td>20335</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Madison</td>\n      <td>F</td>\n      <td>9775.0</td>\n      <td>19562</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Abigail</td>\n      <td>F</td>\n      <td>7821.0</td>\n      <td>15747</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Olivia</td>\n      <td>F</td>\n      <td>7624.0</td>\n      <td>15691</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>32534</th>\n      <td>Zymiere</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>32535</th>\n      <td>Zyrell</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>32536</th>\n      <td>Zyrian</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>32537</th>\n      <td>Zyshon</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>32538</th>\n      <td>Zytavious</td>\n      <td>M</td>\n      <td>NaN</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n<p>32539 rows Ã— 4 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {#71d34103 .cell execution_count=26}\n``` {.python .cell-code}\nnames_right.isnull().sum()\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\nName           0\nSex            0\nCount_x    13415\nCount_y        0\ndtype: int64\n```\n:::\n:::\n\n\n:::{.callout-check-in .icon}\n\nDownload a second GapMinder dataset and merge it with the population dataset from above. Did you have to pivot first? Which order of operations makes the most sense? Is your resulting dataset *tidy*?\n\n:::\n\n\n::: {.callout-practice-exercise .icon}\n\n[Click here](https://colab.research.google.com/drive/12zB93Tb-f1lln5AtX8q1iHv6thlDb4aO?usp=sharing) to solve a riddle using data manipulation.\n\n:::\n\n## Data Wrangling and AI\n\nThe advice in this section applies to data analysis tasks in general, not only to the basic wrangling and summarizing in this chapter - but since this is our first foray in to data wrangling code, let's dive right in!\n\nIn data processing and summarizing, we can think of four main ways that genAI can support your work.  [In this chat](https://chatgpt.com/share/671211e0-6698-8012-889f-c7206aba3d65), we make use of all four of the steps below; open it up and follow along.\n\n#### 1. As a **planner**, to help you chart out your wrangling steps.\n\nData analysis involves going from Point A (your current dataset) to Point B (your desired calculation or visualization).  One of the most difficult aspects of data science is figuring out what intermediate steps will get you there. For this, a genAI tool can be a great \"thinking buddy\" and suggest a path forward.\n\nAlthough it may not give a perfect solution (especially since it typically cannot see your data), two heads are often better than one.  The generated suggestions may include data cleaning steps you hadn't thought of, or help you fill in a gap when you are stuck.\n\nAs always, you will get your best results if your prompt is **well-specified:** make sure to describe the structure of the dataset you have, and the exact nature of the output you are trying to produce.\n\n::: {.callout-example}\nIn our chat example, we got back some pretty useful steps, including a great reminder to make sure our date-time data is the proper *type*.  However, because we weren't overly detailed about the dataset, the AI had to \"guess\" about which columns existed.  And since we also didn't clarify what we wanted our plot to look like, it had to offer an \"optional\" Step 6.\n:::\n\n#### 2. As **documentation**, when you are struggling with the exact use case or syntax of a function.\n\nIt is extremely common in coding to know what function(s) you need for your task, but to be a little fuzzy on the details of how to make then run the way you want.  While the information you need can technically always be found in the official documentation of the functions, these can sometimes be difficult to understand.  One of the absolute *strongest contributions* of genAI is the ability to generate **examples** and to explain every step.  In this regard, the AI tool is much like a human tutor!\n\n::: {.callout-example}\nIn our demo chat, we see that the AI was able to explain the `to_datetime()` function to us in great detail, including several examples of when you might need to use common optional arguments like `format` or `errors`.\n:::\n\n#### 3. As a **search tool**, when you want to find the perfect function.\n\nThe beauty of packages like `pandas` is that many, many functions are provided to give you \"shortcuts\" for common data tasks.  The curse is that you don't always know if a particular function exists!\n\nCertainly, it is possible to look in official documentation - but this can be tedious and involve guessing which functions *might* solve your problem by their name alone.  A better option might be a static search service, like Google - but to trigger useful results, you often need to use key words that precisely describe what you are looking for.\n\nSince genAI tools can interpret human-style text, they are often able to understand what you are looking for and help you find the perfect function.\n\n::: {.callout-example}\nIn response to our question about misspellings in the dataset, the genAI offered two solutions: a simple one for when the possible misspellings are known, and a complex one for general use.  In the second solution, it suggested an additional library called `fuzzywuzzy`.\n:::\n\n#### 4. As a **debugger**, when you can spot where in your analysis something is going wrong.\n\n::: {.callout-example}\n\nHere we wanted to take the mean of a column called `num_admitted`, grouped by `hour` and `severity`.  Unfortunately we made an extremely common mistake of putting the column name inside the `mean()` function.  The genAI tool was able to explain why this approach is wrong, and offer possible solutions.\n\n:::\n\n### Cautionary tales and advice\n\n#### Debugging works best on small pieces\n\nSuppose you write out your full end-to-end data analysis, without testing or checking any intermediate steps, and it does not work as you hoped.  Would you put the whole thing into an LLM for help?\n\nWhile this may work in some straightforward cases, it also may confuse and frustrate you more, as the AI suggests a long list of possible issues for you to comb through.\n\nInstead, we recommend stepping through your analysis line by line, until you reach a step where the results are not what you intended.  (This is good troubleshooting strategy already, and you might find your bug before you even turn to an AI tool!) Then, you can ask the AI about only one or two lines of code that aren't working, and get a more direct and helpful answer.\n\n#### Beware of hallucinations\n\nKeep in mind that a genAI response is not the same as a systematic search: it is producing output trying to mimic what it has seen in the training data.\n\nThis means that if you ask for a function for a particular task, an AI tool **might** simply *invent* a function that seems similar to others it has seen in training.  As AI tools are improving, and training data sources for python code are increasing, hallucinations about code are becoming quite rare.  However, it's important to be aware that AI-produced suggestions are not equivalent to finding the function in official documentation; you'll need to verify for yourself.\n\n",
    "supporting": [
      "04-pivoting_joining_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}